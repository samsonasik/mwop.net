<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/">
  <channel>
    <title>Tag: php :: phly, boy, phly</title>
    <description>Tag: php :: phly, boy, phly</description>
    <pubDate>Sun, 30 Dec 2012 15:52:00 +0000</pubDate>
    <generator>Zend_Feed_Writer 2.0.5 (http://framework.zend.com)</generator>
    <link>http://mwop.net/blog/tag/php.html</link>
    <atom:link rel="self" type="application/rss+xml" href="http://mwop.net/blog/tag/php-rss.xml"/>
    <item>
      <title>OpenShift, Cron, and Naked Domains</title>
      <pubDate>Sun, 30 Dec 2012 15:52:00 +0000</pubDate>
      <link>http://mwop.net/blog/2012-12-30-openshift-cron-and-naked-domains.html</link>
      <guid>http://mwop.net/blog/2012-12-30-openshift-cron-and-naked-domains.html</guid>
      <author>me@mwop.net (Matthew Weier O'Phinney)</author>
      <dc:creator>Matthew Weier O'Phinney</dc:creator>
      <content:encoded><![CDATA[<p>
    As an experiment, I migrated my website over to <a 
    href="http://openshift.redhat.com">OpenShift</a> yesterday. I've been hosting
    a pastebin there already, and have found the service to be both straightforward
    and flexible; it was time to put it to a more thorough test.
</p>

<p>
    In the process, I ran into a number of interesting issues, some of which took quite
    some time to resolve; this post is both to help inform other potential users of the
    service, as well as act as a reminder to myself.
</p><h2>Cron</h2>

<p>
    OpenShift offers a <a href="http://en.wikipedia.org/wiki/Cron">Cron</a> cartridge,
    which I was excited to try out.<sup><a href="#f1">1</a></sup>
</p>

<p>
    The basics are quite easy. In your repository's <code>.openshift</code> 
    directory is a <code>cron</code> subdirectory, further divided into 
    <code>minutely</code>, <code>hourly</code>, <code>daily</code>, <code>weekly</code>,
    and <code>monthly</code> subdirectories. You drop a script you want to run
    into one of these directories, and push your changes upstream.
</p>

<p>
    The problem is: what if I want a job to run at a specific time daily? or on 
    the quarter hour? or on a specific day of the week?
</p>

<p>
    As it turns out, you can manage all of the above, just not quite as succinctly as
    you would in a normal crontab. Here, for example, is a script that I run at 
    5AM daily; I placed it in the <code>hourly</code> directory so that it can test
    more frequently:
</p>

<div class="example"><pre><code language="bash">
#!/bin/bash
if [ `date +%H` == "05" ]
then
    (
        export PHP=/usr/local/zend/bin/php ;
        cd $OPENSHIFT_REPO_DIR ; 
        $PHP public/index.php phlycomic fetch all ; 
        $PHP public/index.php phlysimplepage cache clear --page=pages/comics 
    )
fi
</code></pre></div>

<p>
    And here's one that runs on the quarter-hour, placed in the <code>minutely</code>
    directory:
</p>

<div class="example"><pre><code language="bash">
#!/bin/bash
MINUTES=`date +%M`

for i in "00" "15" "30" "45";do
    if [ "$MINUTES" == "$i" ];then
        (
            export PHP=/usr/local/zend/bin/php ;
            cd $OPENSHIFT_REPO_DIR ;
            $PHP public/index.php githubfeed fetch 
        )
    fi
done
</code></pre></div>

<p>
    The point is that if you need more specificity, push the script into the 
    next more specific directory, and test against the time of execution.
</p>

<h2>Naked Domains</h2>

<p>
    Naked domains are domains without a preceding subdomain. In my case, this
    means "mwop.net", vs. "www.mwop.net".
</p>

<p>
    The problem that cloud hosting presents is that the IP address on which you
    are hosted can change at any time, for a variety of reasons. As such, you
    typically cannot use DNS A records to point to your domain; the recommendation
    is to use a CNAME record that points the domain to a "virtual" domain 
    registered with your cloud hosting provider.
</p>

<p>
    However, most domain registrars and DNS providers do not let you do this for
    a naked domain, particularly if you also have MX or other records associated
    with that naked domain.
</p>

<p>
    Some registrars will allow you to forward the A record to a subdomain. I tried
    this, but had limited success; I personally found that I ended up in an infinite
    loop situation when doing the DNS lookup.
</p>

<p>
    Another solution is to have a redirect in place for your naked domain to the
    subdomain, which can then be a CNAME record. Typically, this would require you
    have a web server under your control with a fixed IP that then simply redirects
    to the subdomain. Fortunately, there's an easier solution: <a 
    href="http://wwwizer.com/naked-domain-redirect">wwwizer</a>. You simply point
    your naked domain A record to the wwwizer IP address, and they will do a 
    redirect to your <code>www</code> subdomain.
</p>

<p>
    I implemented wwwizer on my domain (which is why you'll see "www.mwop.net" in
    your location bar), and it's been working flawlessly since doing so.
</p>

<h4>Private repositories</h4>

<p>
    I keep my critical site settings in a private repository, which allows me 
    to version them while keeping the credentials they hold out of the public eye.
    This means, however, that I need to use <a href="https://help.github.com/articles/managing-deploy-keys">GitHub deploy keys</a> on my server
    in order to retrieve changes.
</p>

<p>
    This was simple enough: I created an <code>ssh</code> subdirectory in my
    <code>$OPENSHIFT_DATA_DIR</code> directory, and generated a new SSH keypair.
</p>

<p>
    The problem was telling SSH to <em>use</em> this key when fetching changes.
</p>

<p>
    The solution is to use a combination of <code>ssh-agent</code> and <code>ssh-add</code>,
    and it looks something like this:
</p>

<div class="example"><pre><code language="bash">
#!/bin/bash
ssh-agent `ssh-add $OPENSHIFT_DATA_DIR/ssh/github-key && (
    cd $OPENSHIFT_DATA_DIR/config ; 
    git fetch origin ; 
    git rebase origin/mwop.net.config
)`
</code></pre></div>

<p>
    After testing the above, I put this in a <code>pre_build</code> script in 
    my OpenShift configuration so that I can autoupdate my private 
    configuration on each build. However, I discovered a new problem: when
    a build is being done, the <code>ssh-agent</code> is not available, which
    means the above cannot be executed. I'm still trying to find a solution.
</p>

<h2>Fin</h2>

<p>
    I'm pretty happy with the move. I don't have to do anything special
    to automate deployment, and all my cronjobs and deployment scripts are now
    self-contained in the repository, which makes my site more portable.
    While a few things could use more documentation, all the pieces are there
    and discoverable with a small amount of work.
</p>

<p>
    I'll likely give some other PaaS providers a try in the future, but for 
    the moment, I'm quite happy with the functionality and flexibility of 
    OpenShift.
</p>

<h4>Footnotes</h4>

<ul>
    <li id="f1">Zend Server's JobQueue can also be used as a cron replacement, 
    but I was not keen on exposing the job functionality via HTTP.</li>
</ul>]]></content:encoded>
      <slash:comments>0</slash:comments>
    </item>
    <item>
      <title>On php-fig and Shared Interfaces</title>
      <pubDate>Thu, 20 Dec 2012 20:23:00 +0000</pubDate>
      <link>http://mwop.net/blog/2012-12-20-on-shared-interfaces.html</link>
      <guid>http://mwop.net/blog/2012-12-20-on-shared-interfaces.html</guid>
      <author>me@mwop.net (Matthew Weier O'Phinney)</author>
      <dc:creator>Matthew Weier O'Phinney</dc:creator>
      <content:encoded><![CDATA[<p>
    This is a post I've been meaning to write for a long time, and one requested
    of me personally by <a href="http://www.rooftopsolutions.nl/blog/">Evert 
    Pot</a> during the Dutch PHP Conference in June 2012. It details some observations
    I have of php-fig, and hopefully will serve as a record of why I'm not
    directly participating any longer.
</p>

<p>
    I was a founding member of the <a href="http://www.php-fig.org/">Framework 
    Interoperability Group</a>, now called "php-fig". I was one of around a dozen 
    folks who sat around a table in 2009 in Chicago during php|tek and started 
    discussions about what we could all do to make it possible to work better 
    together between our projects, and make it simpler for users to pick and choose 
    from our projects in order to build the solutions to their own problems.
</p>

<p>
    The first "standard" that came from this was <a 
    href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md">PSR-0</a>, 
    which promoted a standard class naming convention that uses a 1:1 relationship 
    between the namespace and/or vendor prefix and the directory hierarchy, and the 
    class name and the filename in which it lives. To this day, there are both 
    those who hail this as a great step forward for cooperation, and simultaneously 
    others who feel it's a terrible practice. 
</p>

<p>
    And then nothing, for years. But a little over a year ago, there was a new 
    push by a number of folks wanting to do more. Paul Jones did a remarkable 
    job of spearheading the next <a href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-1-basic-coding-standard.md">two</a> 
    <a href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md">standards</a>, 
    which centered around coding style. Again, just like with PSR-0, we had 
    both those feeling it was a huge step forward, and those who loathe the 
    direction.
</p>

<p>
    What was interesting, though, was that once we started seeing some new energy
    and momentum, it seemed that <em>everyone</em> wanted a say. And we started 
    getting dozens of folks a week asking to be voting members, and new proposal
    after new proposal. Whether or not somebody likes an existing standard, they
    want to have backing for a standard they propose.
</p>

<p>
    And this is when we started seeing proposals surface for shared interfaces, first
    around caching, and now around logging (though the latter is the first up for
    vote).
</p><h2>Shared Interfaces</h2>

<p>
    The idea around shared interfaces is simple: if we can come to a consensus on
    the basic interface for a common application task, libraries and frameworks
    can typehint on that shared interface, allowing developers to drop in the 
    implementation of their choosing -- or even a standard, reference implementation.
    The goal is to prevent Not Invented Here (NIH) syndrome, as well as to make
    it simpler to re-use components between one library and another. As an example,
    if you're using Framework A, and it has a caching library, and you're consuming
    ORM B, you'd be able to pass the same cache object to the ORM as you use in the
    framework.
</p>

<p>
    Great goals, really.
</p>

<p>
    But I'm not sure I buy into them.
</p>

<h2>Problems</h2>

<p>
    First, I agree that NIH is a problem.
</p>

<p>
    Second, I <em>also</em> think there's space for <em>multiple 
    implementations</em> of any given component. Often there are different 
    approaches that different authors will take: one might focus on 
    performance, another on having multiple adapters for providing different 
    capabilities, etc. Sometimes having a different background will present 
    different problem areas you want to resolve. As such, having multiple 
    implementations can be a very good thing; developers can look at what each 
    provides, and determine which solves the particular issues presented in the 
    current project.
</p>

<p>
    Because of this latter point, I have my reservations about shared interfaces.
</p>

<p>
    What if a particular approach requires deviating from the shared interface in 
    order to accomplish its goals? Additionally, in order to keep the greatest
    amount of compatibility between projects, shared interfaces tend to be so
    generic that specific implementations require developers to do a ton of manual
    type checking and munging of parameters, leading to more overhead, more difficulty
    testing and maintaining, and more difficulty documenting and understanding.
</p>

<p>
    As an example, consider the following (made up) signature for a log method:
</p>

<div class="example"><pre><code language="php">
public function log($message, array $context = null);
</code></pre></div>

<p>
    What if your library supports an idea of priorities? Where would that 
    information go in the above signature -- and would that differ between 
    libraries -- would one library use the key for a completely different 
    purpose? What about logging objects -- the signature doesn't say you can't, 
    but how would I know if a specific implementation supports it, and won't 
    blow up if I do pass one? Why must the <code>$context</code> be an array -- 
    why won't any <code>Traversable</code> or <code>ArrayAccess</code> object 
    work?
</p>

<p>
    Basically, by being overly generic, the signature becomes a liability for
    those implementing the interface; it prevents meaningful interoperability
    and leads to splintering implementations.
</p>

<p><em>
    (Please note: the above is completely fictional and has no bearing
    on current proposed or accepted standards. It is a thought exercise
    only.)
</em></p>

<p>
    Furthermore, if a given project writes their own implementation of a 
    component, and it has specialized features, why would they want to typehint
    on a generic, shared interface that doesn't implement those features? This
    would be counter-intuitive, as the project would then need to either check on
    additional interfaces for the specialized capabilities, duck-type, etc. --
    all of which make for more maintenance and code.
</p>

<p>
    In summary, my primary problem with the idea of shared interfaces is that I 
    feel there is always room for new thinking and ideas in any given problem 
    space, and that this thinking should not be restricted by what already 
    exists. Secondarily, I feel that it's okay for a given project to be 
    selective about what capabilities it requires for its internal consumption 
    and consistency, and should not limit itself to a standardized interface.
</p>

<h2>But, but, SHARING</h2>

<p>
    <em>Remember, the first point I made was that I think NIH is a 
    problem.</em> How do I reconcile that with a firm stance against shared 
    interfaces?
</p>

<p>
    Easy: <a href="http://en.wikipedia.org/wiki/Bridge_pattern">bridges</a> 
    and/or <a href="http://en.wikipedia.org/wiki/Adapter_pattern">adapters</a>.
</p>

<p>
    Let's go back to that example of Framework A, its caching library, and working
    with ORM B.
</p>

<p>
    Let's assume that ORM B defines an interface for caching, and let's say it
    looks like this:
</p>

<div class="example"><pre><code language="php">
interface CacheInterface
{
    public function set($key, $data);
    public function has($key);
    public function get($key);
}
</code></pre></div>

<p>
    Furthermore, we'll assume that the expected parameter values and return types
    are documented.
</p>

<p>
    What we as a consumer of both Framework A and ORM B can do is build an 
    <em>implementation</em> of <code>CacheInterface</code> that accepts a cache
    instance from Framework A, and proxies the various interface methods to that
    instance.
</p>

<div class="example"><pre><code language="php">
class FrameworkACache implements CacheInterface
{
    protected $cache;

    public function __construct(Cache $cache)
    {
        $this->cache = $cache;
    }

    public function set($key, $data)
    {
        $item = new CacheItem($key, $data);
        $this->cache->setItem($item);
    }

    public function has($key)
    {
        return $this->cache->exists($key);
    }

    public function get($key)
    {
        $item = $this->cache->getItem($key);
        return $item->getData();
    }
}
</code></pre></div>

<p>
    Assuming your code is well-decoupled, and you're using some sort of Inversion of
    Control container, you can likely create a factory for your ORM that will grab
    the above class, with the cache injected, and inject it into the ORM instance. 
    Yes, it's a bit more work, but it's difficult to question the end result: 
    shared caching between the framework and the ORM - and no need for shared 
    interfaces, nor any need to sacrifice features within the framework or the 
    ORM.
</p>

<h2>Sharing is good, developing solutions is better</h2>

<p>
    I think the core idea of the php-fig group is sound: <em>let's all start thinking
    about how we can make it easier to operate with each other</em>. That said, my 
    thoughts on how to accomplish that goal have changed significantly, and 
    boil down to:
</p>

<ul>
    <li>Use naming conventions that will reduce collisions (i.e., use 
        per-project vendor prefixes/namespaces)</li>
    <li>Use semantic versioning</li>
    <li>Keep your installation packages segregated</li>
    <li>Have a simple, discoverable way to autoload</li>
    <li>Provide interfaces for anything that could benefit from alternate implementations</li>
    <li>Don't write code that has side-effects in the global namespace 
        (including altering PHP settings or superglobals)</li>
</ul>

<p>
    Following these principals, you can play nice with each other, while still 
    fostering innovative and differentiating solutions to shared problems.
</p>]]></content:encoded>
      <slash:comments>0</slash:comments>
    </item>
    <item>
      <title>PHP Master Series on Day Camp For Developers</title>
      <pubDate>Tue, 18 Dec 2012 20:24:00 +0000</pubDate>
      <link>http://mwop.net/blog/2012-12-18-php-master-series.html</link>
      <guid>http://mwop.net/blog/2012-12-18-php-master-series.html</guid>
      <author>me@mwop.net (Matthew Weier O'Phinney)</author>
      <dc:creator>Matthew Weier O'Phinney</dc:creator>
      <content:encoded><![CDATA[<p>
    <a href="http://blog.calevans.com">Cal Evans</a> has organized another 
    DayCamp4Developers event, this time entitled "<a 
    href="http://blog.calevans.com/2012/11/19/php-master-series-vol-1">PHP 
    Master Series, Volume 1</a>". I'm honored to be an invited speaker for this 
    first edition, where I'll be presenting my talk, "Designing Beautiful Software".
</p>

<p>
    Why would you want to participate? Well, for one, because you can interact directly
    with the various speakers during the presentations. Sure, you can likely find the slide
    decks elsewhere, or possibly even recordings. But if we all do our jobs right, we'll
    likely raise more questions than answers; if you attend, you'll get a chance to ask
    some of your questions immediately, <em>and we may even answer them!</em>
</p>

<p>
    On top of that, this is a fantastic lineup of speakers, and, frankly, not a lineup 
    I've ever participated in. In a typical conference, you'd likely see one or two of
    us, and be lucky if we weren't scheduled against each other; if you attend 
    this week, you'll get to see us all, back-to-back. 
</p>

<p>
    What else will you be doing this Friday, anyways, while <a 
    href="http://en.wikipedia.org/wiki/2012_phenomenon">you wait for the end of the 
    world?</a>
</p>

<p>
    So, do yourself a favor, and <a 
    href="http://phpmasterseriesv1.eventbrite.com/">register today</a>!
</p>]]></content:encoded>
      <slash:comments>0</slash:comments>
    </item>
    <item>
      <title>My ZendCon Beautiful Software Talk</title>
      <pubDate>Sat, 17 Nov 2012 13:53:00 +0000</pubDate>
      <link>http://mwop.net/blog/2012-11-17-zendcon-beautiful-software.html</link>
      <guid>http://mwop.net/blog/2012-11-17-zendcon-beautiful-software.html</guid>
      <author>me@mwop.net (Matthew Weier O'Phinney)</author>
      <dc:creator>Matthew Weier O'Phinney</dc:creator>
      <content:encoded><![CDATA[<p>
    Once again, I spoke at <a href="http://www.zendcon.com/">ZendCon</a> 
    this year; in talking with <a href="http://twitter.com/chwenz">Christian Wenz</a>,
    we're pretty sure that the two of us and <a href="http://andigutmans.blogspot.com">Andi</a>
    are the only ones who have spoken at all eight events.
</p>

<p>
    Unusually for me, I did not speak on a Zend Framework topic, and had
    only one regular slot (I also co-presented a Design Patterns tutorial
    with my team). That slot, however, became one of my favorite talks I've
    delivered: "Designing Beautiful Software". I've given this talk a couple
    times before, but I completely rewrote it for this conference in order 
    to better convey my core message: beautiful software is maintainable
    and extensible; writing software is a craft.
</p>

<p>
    I discovered today that not only was it recorded, but it's been <a href="http://youtu.be/mQsQ6QZ4dGg">posted
    on YouTube</a>:
</p>

<iframe width="420" height="315" src="http://www.youtube.com/embed/mQsQ6QZ4dGg" frameborder="0" allowfullscreen></iframe><p>
    I've also <a href="/slides/2012-10-25-BeautifulSoftware/BeautifulSoftware.html">posted the slides</a>.
</p>]]></content:encoded>
      <slash:comments>0</slash:comments>
    </item>
    <item>
      <title>ZF2 Modules Quickstart (Screencast)</title>
      <pubDate>Wed, 19 Sep 2012 18:10:00 +0000</pubDate>
      <link>http://mwop.net/blog/2012-09-19-zf2-module-screencast.html</link>
      <guid>http://mwop.net/blog/2012-09-19-zf2-module-screencast.html</guid>
      <author>me@mwop.net (Matthew Weier O'Phinney)</author>
      <dc:creator>Matthew Weier O'Phinney</dc:creator>
      <content:encoded><![CDATA[<p>
One of the exciting features of the newly released Zend Framework 2 is the new
module system.
</p>

<p>
While ZF1 had modules, they were difficult to manage. All resources for all
modules were initialized on each request, and bootstrapping modules was an
onerous task. Due to the difficulties, modules were never truly "plug-and-play",
and thus no ecosystem ever evolved for sharing modules.
</p>

<p>
In Zend Framework 2, we've architected the MVC from the ground up to make
modular applications as easy as possible. Within ZF2, the MVC simply cares about
events and services — and controllers are simply one kind of service. As such,
modules are primarily about telling the MVC about services and wiring event
listeners.
</p>

<p>
To give you an example, in this tutorial, I'll show you how to install the Zend
Framework 2 skeleton application, and we'll then install a module and see how
easy it is to add it to the application and then configure it.
</p><p>
To keep things simple, I'm using a unix-like environment. As such, if you are on
Windows, you may not have the same command-line tools available. If you are in
such a situation, perhaps try this inside a Linux virtual machine.
</p>

<iframe src="http://player.vimeo.com/video/49775540" 
width="500" height="281" frameborder="0" 
webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>
<p><a href="http://vimeo.com/49775540">Zend Framework 2 Module Quickstart</a></p>

<p>
Let's start by creating a new project. We'll execute a few commands to download
a skeleton application archive and extract it.
</p>

<div class="example"><pre><code language="bash">
% mkdir newproject
% cd newproject
% wget https://github.com/zendframework/ZendSkeletonApplication/tarball/master \
    -O ZendSkeletonApplication.tgz
% tar xzf ZendSkeletonApplication.tgz --strip-components=1
</code></pre></div>

<p>
    The Zend Framework skeleton application can be downloaded directly off of
    <a href="https://github.com">GitHub</a>. I'm showing using the download 
    from master, but you can also download a tarball or zipball for individual 
    tags as well. Because the download URL does not include an extension, I use 
    the <code>-O</code> switch to tell <code>wget</code> what filename to save to.
</p>

<p>
    <code>tar</code> has a nice option, `<code>--strip-components</code>`, which allows you to tell it to
    descend a certain number of levels deep into the archive when deflating. Since I
    know the tarball has a top-level directory named after the repository and a
    sha1, I'm simply telling <code>tar</code> to skip that and give me the contents of its
    child directory.
</p>

<p>
    At this point you have the skeleton application, but it has no dependencies 
    — not even Zend Framework itself! Let's rectify that situation. We'll use the
    dependency management tool <a href="https://getcomposer.org/">Composer</a> 
    to do this. We include the Composer phar file within the skeleton 
    application to make this fairly easy. Simply execute the following:
</p>

<div class="example"><pre><code language="bash">
% php composer.phar install
</code></pre></div>

<p>
    You may get a notice indicating that the composer version is older, and to 
    run "self-update"; you can ignore that for now.
</p>

<p>
    If all goes well, you should now have Zend Framework installed. Let's test 
    it out. I'm going to use the built-in web server in PHP 5.4 to demonstrate.
</p>

<div class="example"><pre><code language="bash">
% cd public
% php -S localhost:8080
</code></pre></div>

<p>
    If I browse to <code>http://localhost:8080</code> I should now see the 
    landing page for the skeleton application.
</p>

<img src="/images/screencasts/2012-09-19-zf2-module-screencast-01-zsa.png" style="width: 100%; height: 100%;" />

<p>
    Let's add a module to the application. Many sites require a contact form. 
    I've written one as a module some time ago, and called it <a 
    href="https://github.com/weierophinney/PhlyContact">PhlyContact</a>. To install
    it, I'll edit my project's <code>composer.json</code> and tell it about that 
    dependency:
</p>

<div class="example"><pre><code language="json">
{
    "require": {
        "php": "&gt;=5.3.3",
        "zendframework/zendframework": "dev-master",
        "phly/phly-contact": "dev-master"
    }
}
</code></pre></div>
    
<p>
    I know the name of the component from <a 
    href="http://packagist.org/">http://packagist.org/</a>, and I'm telling
    Composer that I want to use whatever the latest version is on its master 
    branch on GitHub. I happen to also know that PhlyContact requires a dev-master 
    version of Zend Framework, so I'll alter that dependency for now.
</p>

<p>
    Now, we need to tell composer to update our dependencies.
</p>

<div class="example"><pre><code language="bash">
% php composer.phar update
</code></pre></div>
    
<p>
    After executing the command, we should now see that it has installed; this 
    may take a little while.
</p>

<p>
    You need to inform the application about the module. This is so that we don't
    have to perform expensive file-system scanning operations, but also to make it
    explicit in your code what modules you're actually using. Enabling a module is
    usually as easy as adding an entry to <code>config\application.config.php</code>:
</p>

<div class="example"><pre><code language="php">
'modules' => array(
    'Application',
    'PhlyContact',
),
</code></pre></div>

<p>
    This particular module provides some reasonable defaults. In particular, it uses
    a CAPTCHA adapter that doesn't require additional configuration, and assumes
    that you will want to use the default <code>Sendmail</code> mail transport. As such, we can
    simply browse to it now. I happen to know that the module defines a <code>/contact</code>
    end point. Let's fire up our PHP web server again, and browse to that URL.
</p>

<div class="example"><pre><code language="bash">
% cd public
% php -S localhost:8080
</code></pre></div>

<img src="/images/screencasts/2012-09-19-zf2-module-screencast-02-contact.png" style="width: 100%; height: 100%;" />

<p>
    It just works!
</p>

<p>
    One philosophy we have for distributable modules in Zend Framework 2 is 
    that you should not need to touch the code in modules you install in your application.
    Instead, you should be able to configure and override behavior within the
    application configuration or in your application's site-specific modules. Let's
    alter the contact module to:
</p>

<ul>
    <li>first, change the URL it responds to, and</li>
    <li>second, use the "file" mail transport.</li>
</ul>

<p>
    Let's look at the default configuration. I'll browse to
    <code>vendor/phly/phly-contact/config/</code> and look at the <code>module.config.php</code> file.
</p>

<div class="example"><pre><code language="php">
return array(
    'phly_contact' => array(
        'captcha' => array(
            'class' => 'dumb',
        ),
        'form' => array(
            'name' => 'contact',
        ),
        'mail_transport' => array(
            'class' => 'Zend\Mail\Transport\Sendmail',
            'options' => array(
            )
        ),
        'message' => array(
            /*
            'to' => array(
                'EMAIL HERE' => 'NAME HERE',
            ),
            'sender' => array(
                'address' => 'EMAIL HERE',
                'name'    => 'NAME HERE',
            ),
            'from' => array(
                'EMAIL HERE' => 'NAME HERE',
            ),
             */
        ),
    ),

    /* ... */

    'router' => array(
        'routes' => array(
            'contact' => array(
                'type' => 'Literal',
                'options' => array(
                    'route' => '/contact',
                    'defaults' => array(
                        '__NAMESPACE__' => 'PhlyContact\Controller',
                        'controller'    => 'Contact',
                        'action'        => 'index',
                    ),
                ),
                'may_terminate' => true,
                'child_routes' => array(
                    'process' => array(
                        'type' => 'Literal',
                        'options' => array(
                            'route' => '/process',
                            'defaults' => array(
                                'action' => 'process',
                            ),
                        ),
                    ),
                    'thank-you' => array(
                        'type' => 'Literal',
                        'options' => array(
                            'route' => '/thank-you',
                            'defaults' => array(
                                'action' => 'thank-you',
                            ),
                        ),
                    ),
                ),
            ),
        ),
    ),
    /* ... */
);
</code></pre></div>

<p>
    Okay, that's interesting. I can define the captcha and options to use, the 
    name of the contact form, the mail transport I want to use, and even who the email 
    is sent from and who it goes to. In addition, it defines some routes.
</p>

<p>
    I'll create a new file, <code>config/autoload/phly-contact.local.php</code>. This is a
    local configuration file that will not be checked into my version control
    system. Now, let's add some configuration. First, I'll configure my mail
    transport.
</p>

<div class="example"><pre><code language="php">
return array(
    'phly_contact' => array(
        'mail_transport' => array(
            'class'   => 'Zend\Mail\Transport\File',
            'options' => array(
                'path' => 'data/mail/',
            ),
        ),
    ),
);
</code></pre></div>

<p>
    I'm telling the module to use the <code>File</code> mail transport, and telling the transport
    where I want messages written. By default, Zend Framework calls <code>chdir()</code> to
    change directory to the project root, so I can reference a directory relative to
    that. I'm simply going to write to a <code>data/mail/</code> directory. Let's create that,
    and make it world-writable for now to ensure the web server can write to it. (In
    production, you'd only want it writable by the web server user.)
</p>

<div class="example"><pre><code language="bash">
% mkdir -p data/mail
% chmod a+rwX data/mail
</code></pre></div>

<p>
    Now, let's change the base URL the contact form responds to; I want it to
    respond to <code>/contact-us</code>. Another principle of re-usable modules in ZF2 is that
    we recommend creating tree routes for each module, with the root of the tree
    being a literal route. This makes it easy to alter the base for routing, without
    needing to redefine all the routes in the module.
</p>

<p>
    I'll add the following to my local configuration, then. I'll simply override the
    parent route for my module, named "contact", and point it at a different URL.
</p>

<div class="example"><pre><code language="php">
'router' => array(
    'routes' => array(
        'contact' => array(
            'options' => array(
                'route' => '/contact-us',
            ),
        ),
    ),
),
</code></pre></div>

<p>
    Let's see if all this worked! Once again, I'll fire up PHP's built-in web
    server.
</p>

<div class="example"><pre><code language="bash">
% cd public
% php -S localhost:8080
</code></pre></div>

<p>
    Now, let's browse to <code>http://localhost:8080/contact-us</code> -- looks good! Just as an
    experiment, let's try the previously configured URL,
    <code>http://localhost:8080/contact</code>. We get a 404 now!
</p>

<img src="/images/screencasts/2012-09-19-zf2-module-screencast-03-config.png" style="width: 100%; height: 100%;" />
<img src="/images/screencasts/2012-09-19-zf2-module-screencast-04-404.png" style="width: 100%; height: 100%;" />

<p>
    Now, let's submit the form. I'll fill in some information; it's asking for my
    email address, a subject line, and a message, as well as for me to solve a
    simple CAPTCHA. Once I've done all that, I can send it.
</p>

<p>
    If all is well, we should now have a mail file in our data directory. Let's
    check.
</p>

<div class="example"><pre><code language="bash">
% ls -l data/mail/
</code></pre></div>

<p>
    And now let's look at it.
</p>

<div class="example"><pre><code language="bash">
% cat data/mail/ZendMail_1347989389_1009740165.tmp
Date: Tue, 18 Sep 2012 12:29:49 -0500
From: me@mwop.net
Reply-To: me@mwop.net
Subject: [Contact Form] Suspense!

Suspenseful, isn't it?
</code></pre></div>
    
<p>
    Looks good!
</p>

<p>
    Zend Framework 2 provides a wonderful modular architecture that will enable an
    ecosystem of 3rd party modules that should save you time and energy when
    developing your applications. I've demonstrated a simple one, a contact form,
    but many, many more already exist, and with a stable release now available, you
    should see that number grow. This is truly a wonderful step forward for
    developers, and I hope you find it as exciting as I do.
</p>]]></content:encoded>
      <slash:comments>0</slash:comments>
    </item>
    <item>
      <title>On Microframeworks</title>
      <pubDate>Fri, 17 Aug 2012 16:00:00 +0000</pubDate>
      <link>http://mwop.net/blog/2012-08-17-on-microframeworks.html</link>
      <guid>http://mwop.net/blog/2012-08-17-on-microframeworks.html</guid>
      <author>me@mwop.net (Matthew Weier O'Phinney)</author>
      <dc:creator>Matthew Weier O'Phinney</dc:creator>
      <content:encoded><![CDATA[<p>
    A number of months ago, <a href="http://funkatron.com/">Ed Finkler</a> 
    started a discussion in the PHP community about &#8220;<a 
    href="http://microphp.org/">MicroPHP</a>&#8221;; to summarize, the movement
    is about:
</p>

<ul>
    <li>Building small, single-purpose libraries.</li>
    <li>Using small things that work together to solve larger problems.</li>
</ul>

<p>
    I think there are some really good ideas that have come out of this, and 
    also a number of questionable practices<sup><a name="t1" href="#f1">1</a></sup>.
</p>

<p>
    One piece in particular I've focussed on is the concept of so-called 
    &#8220;microframeworks&#8221;.
</p><h2>What is a microframework?</h2>

<p>
    PHP has had microframeworks for quite some time<sup><a name="t2" href="#f2">2</a></sup>, 
    though I only really first saw the term being used around 3 years ago. The 
    &#8220;grand-daddy&#8221; of modern-day microframeworks can actually be 
    traced to Ruby, however, and specifically 
    <a href="http://www.sinatrarb.com">Sinatra</a>.
</p>

<p>
    Sinatra is not so much a framework as it is a domain-specific language (DSL).
    The language and structure it created, however, have been re-created in the
    vast majority of microframeworks you see currently in the PHP arena. 
    Specifically, it describes how to map HTTP request methods and paths to the
    code that will handle them. It borrowed route matching ideas from
    <a href="http://rubyonrails.org/">Ruby on Rails</a>, and relied on the fact 
    that Ruby uses the last value of a block as the return value.
</p>

<p>
    As some simple examples:
</p>

<div class="example"><pre><code language="ruby">
get '/hello/:name' do |n|
    "Hello #{n}!"
end

post '/address'
    # create address
end

put '/address/:id' |i|
    # update address
end

get '/feed.?:format?', :provides => ['rss', 'atom', 'xml'] do
    builder :feed
end
</code></pre></div>

<p>
    The language is expressive, and allows the developer to focus on two things:
</p>

<ul>
    <li>What are the specific entry points (URIs) for the application?</li>
    <li>What needs to be done for each specific entry point?</li>
</ul>

<p>
    I'd argue that the above two points are the defining characteristics of 
    modern microframeworks. Typically, the entry points are given the term
    &#8220;routing &#8221;, and the second corresponds to &#8220;controllers&#8221;.
</p>

<h2>PHP implementations</h2>

<p>
    I'd argue one of the earliest microframework implementations, though it 
    wasn't termed as such, was <a href="http://dev.horde.org/routes/">Horde 
    Routes</a><sup><a name="t3" href="#f3">3</a></sup> (which was itself inspired by <a 
    href="http://routes.readthedocs.org/en/latest/index.html">Python Routes</a>, 
    in turn inspired by the Rails routing system, like Sinatra). It follows
    the two principles I outlined above: it allows defining routes (entry points),
    and mapping them to controllers. Controllers for Routes are simply classes, 
    and a route must provide both a controller and an action in the match, with 
    the latter corresponding to a method on the controller class.
</p>

<p>
    Since around 2009, I've seen an increasing number of new PHP microframeworks<sup><a name="t4" href="#f4">4</a></sup>
    that follow in the steps of Sinatra and Horde. In the various 
    implementations I've looked at, instead of using a DSL, the authors have all
    opted for either a procedural or OOP interface. Starting with PHP 5.3, most
    authors have also primarily targetted any PHP callable as a controller, 
    favoring callbacks specifically. The fundamental ideas remain the same as 
    Sinatra, however:
</p>

<div class="example"><pre><code language="php">
/* Procedural */
get('/hello/:name', function ($n) {
    return "Hello {$n}!";
});

post('/address', function () {
    // create address
});

put('/address/:id' function ($i) {
    // update address
});

get('/feed.?:format?', function($feed, $format) {
    return builder($feed, $format);
});

/* OOP */
$app->get('/hello/:name', function ($n) {
    return "Hello {$n}!";
});

$app->post('/address', function () {
    // create address
});
end

$app->put('/address/:id', function ($i) {
    // update address
});

$app->get('/feed.?:format?', function ($feed, $format) use ($app) {
    return $app->builder($feed, $format);
})->constraints(['format' => '/^(rss|atom|xml)$/']);
</code></pre></div>

<p>
    One key difference I've witnessed in the implementations is surrounding
    how route matches are passed to the callback. In the examples above, they
    are passed as individual arguments to the handler. Some, however, opt for
    an approach more like Sinatra, which passes a single "params" argument into
    the scope of the handler. This approach tends to be more expedient both 
    from an implementation standpoint as well as a performance standpoint, as
    it does not require reflection to determine name and position of arguments,
    and makes handling wildcard arguments simpler. I've seen this latter 
    approach handled several ways:
</p>

<div class="example"><pre><code language="php">
// Pass in route match parameters as an argument.
$app->get('/feed.:format', function ($params) {
    $format = $params['format'];
});

// Pass in the $app instance, and retrieve route 
// match parameters from it.
$app->get('/feed.:format', function ($app) {
    $format = $app->params('format');
});

// Curry in the $app instance when desired, and 
// retrieve route match parameters from it.
$app->get('/feed.:format', function () use ($app) {
    $format = $app->params('format');
});
</code></pre></div>

<p>
    Another difference I've seen is in how route constraints, defaults, and
    names are handled. The most elegant solutions usually allow chaining
    method calls in order to alter this data:
</p>

<div class="example"><pre><code language="php">
$app->get('/feed.:format', function ($app) {
  })->constraints(['format' => '/^(atom|xml|json)$/'])
    ->name('feed');
</code></pre></div>

<p>
    One common feature I've seen is the ability to generate URLs based on the 
    defined routes. Most commonly, this is a function or method 
    <code>urlTo()</code>, which takes a route name, and an associative array
    of replacements.
</p>

<div class="example"><pre><code language="php">
echo $app->urlTo('feed', ['format' => 'atom']);
</code></pre></div>

<p>
    That's it in a nutshell: the ability to match HTTP request methods and
    path information, and map it to controllers/handlers, and to generate
    URLs based on those present in the application.
</p>

<h2>What are they good for?</h2>

<p>
    In my research and experience, microframeworks have three typical use cases:
</p>

<ol>
    <li>
        <b>Prototyping.</b> Because of their simplicity, microframeworks are 
        fantastic for prototyping a basic website. Very often, in the early
        stages of a site, you have a limited number of pages, and most often
        simply need to render a template with limited variable substitutions.
        Microframeworks are a perfect fit for this.
    </li>

    <li>
        <b>APIs</b>. API needs are usually quite well-defined, and often 
        involve a small, finite number of URLs. The logic required is usually
        already encapsulated in business objects, so the application layer
        is simply for filtering and returning a representation. Microframeworks
        again offer a nice fit.
    </li>

    <li>
        <b>Small, mostly static sites</b>. Similar to the first point, if you
        know the site will be relatively small and mostly static, then the
        minimal overhead of a microframework is often a good fit.
    </li>
</ol>

<h2>Where do microframeworks fail?</h2>

<p>
    Because of the rather declarative nature of microframeworks, and the
    typically 1:1 mapping of a route to a controller, microframeworks do
    not tend to promote code re-use. Additionally, this extends to how
    microframework applications are organized: usually, there are no clear
    guidelines on how to organize routes and controllers, much less separate
    them into multiple files. This can lead to maintenance issues as the
    application grows, as well as logistical issues whenever you need to 
    add new routes and controllers (do they go at the top, or bottom? are
    there other routes that could potentially match as well? etc.). 
</p>

<p>
    Additionally, though many frameworks offer ways to alter the workflow
    of the application either via hooks, events, or &#8220;middleware&#8221;<sup><a name="t5" href="#f5">5</a></sup>,
    most of these are limited in scope, often non-reusable, and often
    non-stackable. As such, comprehensive manipulation of the application
    workflow is out of reach.
</p>

<p>
    One other area that is overlooked, however, is one I find curious, 
    particularly in light of the MicroPHP movement: so much of the
    underlying plumbing is basically the same, yet every microframework
    re-implements it. Specifically:
</p>

<ul>
    <li>
        Routing is basically the same across most implementations, following the
        same basic specifications outlined in Rails. There are very few differences
        in the public APIs.
    </li>

    <li>
        Request and Response object abstraction is largely the same as well, 
        providing access to query/post/cookie/session/etc. parameters through
        roughly equivalent APIs.
    </li>

    <li>
        Many implement their own view layers.<sup><a name="t6" href="f6">6</a></sup>
    </li>
</ul>

<p>
    Most of this code should be considered commodity code at this point. There are 
    several outstanding view layers and templating engines available (Smarty, Twig,
    Savant, Zend\View). Standalone routing libraries exist such as Horde Routes,
    and even those bundled with frameworks are often available separately via
    Composer or Pyrus; the same is true with Request and Response object 
    abstraction. It seems to me that a few microframework authors should be 
    working on abstracting these concerns, and then focussing their efforts on
    differentiators in their own microframeworks.
</p>

<h2>An experiment</h2>

<p>
    Building on my last point, I looked at the APIs of <a 
    href="http://limonade-php.github.com/">Limonade</a> and <a 
    href="http://www.slimframework.com/">Slim Framework</a>, and built up a 
    specification for a microframework. I then matched as many pieces of it 
    as possible to existing components in <a 
    href="http://packages.zendframework.com/">ZF2</a>, and started building.
</p>

<p>
    In a matter of a few hours, I had written up a complete test suite<sup><a name="t7" href="#f7">7</a></sup> 
    and all code for a microframework, featuring the following (this is 
    basically the testdox output from the unit test suite):
</p>

<ul>
    <li>Lazy loads request</li>
    <li>Lazy loads response</li>
    <li>Request is injectible</li>
    <li>Response is injectible</li>
    <li>Halt should raise halt exception</li>
    <li>Response should contain status provided to halt</li>
    <li>Response should contain message provided to halt</li>
    <li>Stop should raise halt exception</li>
    <li>Response should remain unaltered after stop</li>
    <li>Redirect should raise halt exception</li>
    <li>Redirect should set 302 response status by default</li>
    <li>Redirect should set response status based on provided status code</li>
    <li>Redirect should set location header</li>
    <li>Map creates a segment route when provided with a string route</li>
    <li>Map can receive a route object</li>
    <li>Passing invalid route raises exception</li>
    <li>Map can receive a callable</li>
    <li>Passing invalid controller to route does not immediately raise exception</li>
    <li>Accessing invalid controller raises exception</li>
    <li>Passing invalid method to route via method raises exception</li>
    <li>Can set methods route responds to singly</li>
    <li>Can set methods route responds to as array</li>
    <li>Can set methods route responds to as multiple arguments</li>
    <li>Can specify additional method types to respond to</li>
    <li>Can specify route name</li>
    <li>Adding route using method type creates route that responds to that method type</li>
    <li>Running with no matching routes raises page not found exception</li>
    <li>Routing sets list of named routes</li>
    <li>Routing sets lists of routes by method</li>
    <li>Successful routing dispatches controller</li>
    <li>Unsuccessful routing triggers 404 event</li>
    <li>Calling halt triggers halt event</li>
    <li>Invalid controller triggers 501 event</li>
    <li>Exception raised in controller triggers 500 event</li>
    <li>Can pass to next matching route</li>
    <li>Url for helper assembles url based on name provided</li>
    <li>Url for helper assembles url based on name and params provided</li>
    <li>Url for helper assembles url based on current route match when no name provided</li>
    <li>Composes logger instance by default</li>
    <li>Can inject specific logger instance</li>
    <li>Mustache view is used by default</li>
    <li>Can inject alternate view instance</li>
    <li>Render renders a template to the response</li>
    <li>View model returns mustache view model by default</li>
    <li>Subsequent calls to view model return separate instances</li>
    <li>Can provide view model prototype</li>
</ul>

<p>
    I utilized ZF2's routing library from its MVC component, the request and response
    objects from its HTTP component, its Log component, and the Session component. These
    had a few other dependencies, but nothing terribly onerous.
</p>

<p>
    For the view, I used my own <a 
    href="http://weierophinney.github.com/phly_mustache">phly_mustache</a>, and provided
    a basic "view model" implementation that receives the application instance, thus
    allowing the ability to call application helpers (such as url generation).
</p>

<p>
    To make installation simple, I used <a href="http://getcomposer.org">Composer</a>
    to manage my dependencies on specific ZF2 components and for phly_mustache. The
    microframework contains only the code it needs to get its work done, leveraging
    the work of others whenever possible.
</p>

<p>
    This post is not meant as a way to announce a new microframework, however.<sup><a name="t8" href="#f8">8</a></sup>
    The point of the experiment was to prove something: microframeworks are
    trivially easy to write, <em>particularly if you follow the principals of 
    MicroPHP, and re-use existing code</em>. Just because code comes from a framework
    or a third-party library does not make it suspect or inferior; in fact,
    whenever possible, you should leverage such code so you can focus on 
    <em>writing awesome applications</em>.
</p>

<h2>Lessons learned</h2>

<p>
    I really like microframeworks for specific problems: prototyping, APIs, and 
    small, simple sites. I think they are ideally suited for these tasks. That
    said, I'd love to see some solid libraries targetting the fundamental, shared
    aspects of these efforts: routing, request and response abstraction, etc.
    With dependency management tools such as Composer and Pyrus, having required
    dependencies is not a big deal anymore, and re-use should be encouraged.
</p>

<p>
    Also, writing a microframework is an excellent coding exercise. It helps a 
    developer appreciate the complexities of abstraction while limiting the number
    of moving parts. I highly recommend it as an exercise -- but do it using 
    available components, and be prepared to throw it away and instead collaborate
    with others, or adopt something which better solves both the problems you have
    and the problems you anticipate.
</p>

<p>
    In sum: <em>Use the right tool for the job</em>. If you foresee expanding 
    requirements in your project's future, you may want to evaluate a full-stack
    framework,<sup><a name="t9" href="#f9">9</a></sup> or consider building something 
    robust that suits your specific project's needs. Use microframeworks where
    and when they make sense.
</p>

<h4>Afterword</h4>

<p>
    I'm well aware that Fabien Potencier has written
    <a href="http://fabien.potencier.org/article/50/create-your-own-framework-on-top-of-the-symfony2-components-part-1">a comprehensive series of posts on creating a microframework using Symfony 2
    components</a>. I deliberately chose not to read them until (a) ZF2 was 
    almost ready to release, and (b) I'd had a chance to formulate my own
    opinions on microframeworks. They're an excellent read, however, and show a 
    nice progression of development from flat PHP to a fully functional 
    microframework; click the link and see for yourself.
</p>

<h4>Footnotes</h4>

<ul>
    <li>
        <sup><a name="f1" href="#t1">1</a></sup> In particular, I feel that the movement 
        (a) disparages components from larger libraries simply because they
        originate from a larger library, and (b) distrust any code that has 
        additional dependencies. This latter I find truly puzzling, as I'd 
        think it fits the idea of &#8220;use small things that work together to 
        solve larger problems.&#8221; If the code solves a particular problem
        and allows you to focus on a larger problem, where it originates and 
        the number of dependencies should not be an issue.
    </li>

    <li>
        <sup><a name="f2" href="#t2">2</a></sup> In fact, my first foray into MVC in PHP 
        was writing a clone of Perl's <a href="http://cgi-app.org/">CGI::Application</a>,
        which in many ways is also a microframework.
    </li>

    <li>
        <sup><a name="f3" href="#t3">3</a></sup> Trivia: Both authors of Horde Routes 
        worked at Zend when I first started at the company, and Mike Naberezny
        wrote the very first lines of code for Zend Framework.
    </li>

    <li>
        <sup><a name="f4" href="#t4">4</a></sup> I swear, you see new ones on Github daily,
        and on <a href="http://phpdeveloper.org/">PHP Developer</a> at least
        once a week.
    </li>

    <li>
        <sup><a name="f5" href="#t5">5</a></sup> <a href="http://www.slimframework.com">Slim</a>
        has this concept. Basically, any callables placed between the route 
        string and the last callable when defining a route -- i.e., the &#8220;middle&#8221;
        arguments, and thus middleware -- will be executed in order prior to 
        attempting to execute the controller.
    </li>

    <li>
        <sup><a name="f6" href="#t6">6</a></sup> <a href="http://www.slimframework.com">Slim</a>
        is an outlier here, as it utilizes <a href="http://twig.sensiolabs.org/">Twig</a>
        by default.
    </li>

    <li>
        <sup><a name="f7" href="#t7">7</a></sup> I'm sure that my TDD experiment will warm the
        soul of <a href="http://www.littlehart.net/atthekeyboard/" alt="Chris 
        Hartjes">the Grumpy Programmer</a>.
    </li>

    <li>
        <sup><a name="f8" href="#t8">8</a></sup> That said, if you want to look at the results, 
        you can <a href="http://github.com/weierophinney/phlyty">find Phlyty on Github</a>.
    </li>

    <li>
        <sup><a name="f9" href="#t9">9</a></sup> As you may guess, I'm biased towards <a 
        href="http://framework.zend.com/">Zend Framework</a>. However, you should always
        carefully evaluate a framework against your project's needs.
    </li>
</ul>]]></content:encoded>
      <slash:comments>0</slash:comments>
    </item>
    <item>
      <title>ZF2's New Controller::init()</title>
      <pubDate>Tue, 31 Jul 2012 02:00:00 +0000</pubDate>
      <link>http://mwop.net/blog/2012-07-30-the-new-init.html</link>
      <guid>http://mwop.net/blog/2012-07-30-the-new-init.html</guid>
      <author>me@mwop.net (Matthew Weier O'Phinney)</author>
      <dc:creator>Matthew Weier O'Phinney</dc:creator>
      <content:encoded><![CDATA[<p>
    In Zend Framework 1, controller's had an <code>init()</code> method, which
    was called after the controller was instantiated. The reason for it was to
    encourage developers not to override the constructor, and thus potentially
    break some of the functionality (as a number of objects were injected via
    the constructor). <code>init()</code> was useful for doing additional object
    initialization.
</p>

<div class="example"><pre><code language="php">
class MyController extends Zend_Controller_Action
{
    public function init()
    {
        // do some stuff!
    }
}
</code></pre></div>

<p>
    But this feature is missing from ZF2; how can we accomplish this sort of
    pattern?
</p><h2>Constructor Overriding</h2>

<p>
    Why didn't we add the <code>init()</code> method in Zend Framework 2?
    Because we don't have a constructor by default, and also to reduce overall
    method calls; if a controller won't be overriding the method, there's no
    reason to make the call in the first place.  So, that means, in ZF2, unlike
    ZF1, to do the same thing, you can simply define a constructor in your
    controller:
</p>

<div class="example"><pre><code language="php">
use Zend\Mvc\Controller\AbstractActionController;

class MyController extends AbstractActionController
{
    public function __construct()
    {
        // do some stuff!
    }
}
</code></pre></div>

<p>
    Except there's one specific and often-needed use case where this fails: if
    you want to wire listeners to the controller's event manager.
</p>

<h2>Events</h2>

<p>
    Why does this fail with the event manager? Because when we're in the
    constructor, we don't yet have an <code>EventManager</code> instance!
    The event manager instance is injected after instantiation. As such, we
    need to attach to it once we know we have an event manager. Which is...
    when it's set. This can be done very simply by overriding the
    <code>setEventManager()</code> method. In the next example, we'll
    define a listener for the "dispatch" event that redirects if certain
    criteria is not met.
</p>

<div class="example"><pre><code language="php">
use Zend\EventManager\EventManagerInterface;
use Zend\Mvc\Controller\AbstractActionController;

class MyController extends AbstractActionController
{
    public function setEventManager(EventManagerInterface $events)
    {
        parent::setEventManager($events);

        $controller = $this;
        $events->attach('dispatch', function ($e) use ($controller) {
            $request = $e->getRequest();
            $method  = $request->getMethod();
            if (!in_array($method, array('PUT', 'DELETE', 'PATCH'))) {
                // nothing to do
                return;
            }

            if ($controller->params()->fromRoute('id', false)) {
                // nothing to do
                return;
            }

            // Missing identifier! Redirect.
            return $controller->redirect()->toRoute(/* ... */);
        }, 100); // execute before executing action logic
    }
}
</code></pre></div>

<p>
    The beauty of this is that we only override when we need to, and we override
    in the specific context we're trying to influence. Additionally, we're only
    registering the event listener if this particular controller is instantiated
    -- which helps reduce our overall number of listeners, and thus shapes our
    call graph based on the controller invoked.
</p>

<h2>Other dependencies</h2>

<p>
    As you'll likely note, the event manager is not the only case where you may
    need to follow a similar pattern. Any time your initialization logic may be
    based on a dependency, you'll want to override the setter in which that
    dependency is injected.
</p>

<p>
    <em>Got any ZF2 tips of your own to share? Blog them!</em>
</p>

<h2>Update: ServiceManager</h2>

<p>
    A few folks in the comments were remarking that the felt that omitting the
    <code>init()</code> method makes it harder for developers to identify when
    and where to do initialization logic, particularly when you may be working
    with multiple dependencies.
</p>

<p>
    Which made me realize there's another place I missed, one that's potentially
    even better suited to initialization: the <code>ServiceManager</code>.
</p>

<p>
    Basically, if you find yourself having complex initialization needs, or
    many dependencies, you should be building a factory for your controller, and
    wiring it to the <code>ServiceManager</code>. This can happen in one of
    several places, but my preference is in my module's <code>Module</code>
    class, in the <code>getControllerConfig()</code> method. This method returns
    configuration for the controller manager that instantiates, validate, and
    injects controllers; it's basically a type of <code>ServiceManager</code>,
    and, in fact, has access to the main application's instance. I'll take the
    previous example, and wire it in the context of a factory:
</p>

<div class="example"><pre><code language="php">
namespace My

use Zend\EventManager\EventManagerInterface;

class Module
{
    /*
     * Assume some other methods, such as getConfig(), etc.
     * Also assume that a route will return a controller named
     * "My\Controller\My" which we assume will reference a controller
     * within our current namespace.
     */

    public function getControllerConfig()
    {
        return array('factories' => array(
            'My\Controller\My' => function ($controllers) {
                $services   = $controllers->getServiceLocator();
                $controller = new Controller\MyController();
                $events     = $services->get('EventManager')

                $events->attach('dispatch', function ($e) use ($controller) {
                    $request = $e->getRequest();
                    $method  = $request->getMethod();
                    if (!in_array($method, array('PUT', 'DELETE', 'PATCH'))) {
                        // nothing to do
                        return;
                    }

                    if ($controller->params()->fromRoute('id', false)) {
                        // nothing to do
                        return;
                    }

                    // Missing identifier! Redirect.
                    return $controller->redirect()->toRoute(/* ... */);
                }, 100); // execute before executing action logic

                $controller->setEventManager($events);
                return $controller;
            };
        ));
    }
}
</code></pre></div>

<p>
    The above will create the controller, grab an event manager instance,
    attach the listener, and then inject the event manager into the controller.
    If you wanted to do more complex work, you definitely could -- and this
    would be the place to do it.
</p>]]></content:encoded>
      <slash:comments>0</slash:comments>
    </item>
    <item>
      <title>ZF2 Forms in Beta5</title>
      <pubDate>Thu, 05 Jul 2012 20:40:00 +0000</pubDate>
      <link>http://mwop.net/blog/2012-07-02-zf2-beta5-forms.html</link>
      <guid>http://mwop.net/blog/2012-07-02-zf2-beta5-forms.html</guid>
      <author>me@mwop.net (Matthew Weier O'Phinney)</author>
      <dc:creator>Matthew Weier O'Phinney</dc:creator>
      <content:encoded><![CDATA[<p>
    Forms are a nightmare for web development. They break the concept of 
    separation of concerns:
</p>

<ul>
    <li>They have a <em>display</em> aspect (the actual HTML form)</li>
    <li>They have a <em>validation</em> aspect</li>
    <li>And the two mix, as you need to display validation error messages.</li>
</ul>

<p>
    On top of that, the submitted data is often directly related to your domain
    models, causing more issues:
</p>

<ul>
    <li>Not all elements will have a 1:1 mapping to the domain model -- 
    buttons, CSRF protection, CAPTCHAs, etc. usually are application-level 
    concerns, but not domain issues.</li>
    <li>Names valid for your domain model may not be valid names for HTML 
    entities.</li>
</ul>

<p>
    Add to this that the validation logic may be re-usable outside of a forms 
    context, and you've got a rather complex problem.
</p><h2>Forms in ZF2</h2>

<p>
    Starting in 2.0.0beta4, we offerred a completely rewritten Form component. 
    In fact, it's not just a Form component -- a new component, InputFilter, 
    was also added. InputFilter is a component that provides re-usable validation
    and normalization logic, and can be used with forms or your domain model.
    The Form component is basically a bridge between domain models/validation 
    and the view layer.
</p>

<p>
    However, this means a bit more complexity for the end-user. You now must:
</p>

<ul>
    <li>Create your form, which consists of elements and fieldsets.</li>
    <li>Create an input filter, consisting of inputs.</li>
    <li>Inform the form of the input filter.</li>
</ul>

<p>
    It's a bit of work. And there's more: we wanted to simplify the process of
    getting your validated values into your domain objects. For this, we added
    a concept of <em>hydrators</em>, which map the validated form values to
    an object you <em>bind</em> to the form. Now you have <em>three</em> pieces
    to keep track of -- form (and its elements), input filter (and its inputs),
    and a hydrator.
</p>

<p>
    So, a few developers had an idea: use annotations on the domain model objects
    to define these items, letting you keep it all in one place.
</p>

<p>
    While I'm not normally a fan of annotations, I immediately saw the appeal 
    in this particular situation.
</p>

<h2>An Example</h2>

<p>
    Let's consider a very simple example. The following domain object represents
    data for a user, and includes a variety of elements we'd represent in a form.
</p>

<div class="example"><pre><code language="php">
namespace MyVendor\Model;

use Zend\Form\Annotation;

/**
 * @Annotation\Hydrator("Zend\Stdlib\Hydrator\ObjectProperty")
 * @Annotation\Name("user")
 */
class User
{
    /**
     * @Annotation\Attributes({"type":"text" })
     * @Annotation\Validator({"type":"Regex","options":{"regex":"/^[a-zA-Z][a-zA-Z0-9_-]{1,19}/"}})
     * @Annotation\Options({"label":"Username:"})
     */
    public $username;

    /**
     * @Annotation\Required(false)
     * @Annotation\Attributes({"type":"text" })
     * @Annotation\Options({"label":"Your full name:"})
     */
    public $fullname;

    /**
     * @Annotation\Type("Zend\Form\Element\Email")
     * @Annotation\Options({"label":"Your email address:"})
     */
    public $email;

    /**
     * @Annotation\Type("Zend\Form\Element\Url")
     * @Annotation\Options({"label":"Your home page:"})
     */
    public $uri;
}
</code></pre></div>

<p>
    So, what does the above do?
</p>

<ul>
    <li>The "name" annotation gives a form or element a specific name.</li>
    <li>The "attributes" annotation indicates what attributes to compose into 
        the form or element.</li>
    <li>Similarly, the "options" annotation specifies options to compose into
        an element. These typically include the label, but may include other
        configuration that doesn't have an exact analog in the HTML attributes.</li>
    <li>The "validator" annotation indicates a validator to compose for the 
        input for a given element. We also ship a "filter" annotation.</li>
    <li>The "type" annotation indicates a class to use for that particular form 
        or element. In the specific cases used above, the elements actually 
        provide default filters and validators, simplifying setup further!</li>
    <li>Last, but not least, the "hydrator" annotation indicates a 
        <code>Zend\Stdlib\Hydrator</code> implementation to use to relay data 
        between the form and the object.  I'll cover this more shortly.</li>
</ul>

<p>
    So, let's now turn to creating a form and consuming it.
</p>

<div class="example"><pre><code language="php">
use MyVendor\Model\User;
use Zend\Form\Annotation\AnnotationBuilder;

$user    = new User();
$builder = new AnnotationBuilder();
$form    = $builder->createForm($user);

$form->bind($user);
$form->setData($dataFromSomewhere);
if ($form->isValid()) {
    // $user is now populated!
    echo $form->username;
    return;
} else {
    // probably need to render the form now.
}
</code></pre></div>

<p>
    You're not quite done, really -- most likely, you'll need to include a 
    submit button of some sort, and it's always good practice to include a
    token to prevent CSRF injections. But with the above, you've accomplished
    the major headaches of setting up a form -- and using the data -- with 
    minimal fuss.
</p>


<h2>Much more!</h2>

<p>
    The form support in ZF2 offers a ton of other features, some of which
    are not specific to forms even.
</p>

<ul>
    <li>
        <p>
            ZF2 supports a variety of hydration strategies, which allow you to pass
            data to and from objects. The example above uses one that suggests a 1:1
            mapping between the inputs and the object properties; other strategies
            include using <code>ArrayObject</code>, using class mutator 
            methods, and more.
        </p>

        <p>
            At this point, you can hydrate an entire form, as well as individual
            fieldsets!
        </p>
    </li>

    <li>
        <p>
            You can provide custom annotations. While this feature is not 
            documented yet, you can tell the <code>AnnotationBuilder</code> 
            about additional annotation classes, as well as provide listeners
            for those annotations so that they can interact with the form
            construction process. As an example, one contributor has already
            used these features to utilize <a 
            href="http://doctrine-project.org">Doctrine</a> annotations to
            inform the builder about the name of a property, as well as
            indicate validators. (Side note: ZF2 now uses Doctrine's annotation
            syntax and parser by default.)
        </p>
    </li>

    <li>
        <p>
            There are a number of features targetting collections, so that
            your client-side code can return arbitrary numbers of a specific
            fieldset type (e.g., collecting addresses for an applicant), and
            the form will be able to validate each. You can <a 
            href="http://www.michaelgallego.fr/blog/?p=190">read more about 
            those features from the author himself</a>.
        </p>
    </li>
</ul>

<p>
    These features are all now available starting with the newly released 
    2.0.0beta5 version, which you can grab from the <a 
    href="http://packages.zendframework.com/">ZF2 packages site</a>. 
</p>

<p>
    I'm really excited with the solutions we've created in ZF2, and even more
    excited to see people put them to use!
</p>]]></content:encoded>
      <slash:comments>0</slash:comments>
    </item>
    <item>
      <title>On Visibility in OOP</title>
      <pubDate>Sat, 30 Jun 2012 15:00:00 +0000</pubDate>
      <link>http://mwop.net/blog/2012-06-28-oop-visibility.html</link>
      <guid>http://mwop.net/blog/2012-06-28-oop-visibility.html</guid>
      <author>me@mwop.net (Matthew Weier O'Phinney)</author>
      <dc:creator>Matthew Weier O'Phinney</dc:creator>
      <content:encoded><![CDATA[<p>
    I'm a big proponent of object oriented programming. OOP done right helps 
    ease code maintenance and enables code re-use.
</p>

<p>
    Starting in PHP, OOP enthusiasts got a whole bunch of new tools, and new
    tools keep coming into the language for us with each minor release. One
    feature that has had a huge impact on frameworks and libraries has been
    available since the earliest PHP 5 versions: visibility.
</p><h2>Theory</h2>

<p>
    The visibility keywords include <em>private</em>, <em>protected</em>, and 
    <em>public</em>, often referred to as <strong>PPP</strong>. There's an 
    additional keyword I often lump in with them, <em>final</em>.
</p>

<p>
    Public visibility is the default, and equivalent to the only visibility
    available to PHP prior to version 5: any member declared public is 
    accessible from any scope. This means the following:
</p>

<div class="example"><pre><code lang="php">
class Foo
{
    public $bar = 'bar';

    public function baz() 
    {
        // I can access within my own scope
        return $this->bar;
    }
}

class FooBar extends Foo
{
    public function doThat()
    {
        // I have access to members in my parent
        return $this->bar . $this->baz();
    }
}

$foo = new Foo();

// I can access public members from an instance
echo $foo->bar . $foo->baz();
</code></pre></div>

<p>
    Basically, public visibility means that I can access the member from 
    within the object, within an extending class, or from simply an instance.
</p>

<p>
    Protected visibility starts to tighten things down a little. With protected 
    visibility, only the class itself, or an extending class, can access the 
    member:
</p>

<div class="example"><pre><code lang="php">
class Foo
{
    protected $bar = 'bar';

    protected function baz() 
    {
        // I can access within my own scope
        return $this->bar;
    }
}

class FooBar extends Foo
{
    public function doThat()
    {
        // I can access protected members in my parent
        return $this->bar . $this->baz();
    }
}

$foo = new FooBar();

// This works, as I'm calling a public member of an extending class:
$foo->doThat();

// But these are both illegal:
echo $foo->bar . $foo->baz();
</code></pre></div>

<p>
    Protected visibility is nice for hiding things from those consuming your
    class. It can be used to hide implementation details, and to prevent direct
    modification of public properties -- something important to consider, if
    a property may be the product of calculation, or if a particular type is
    required.
</p>

<p>
    Private visibility locks things down further. With private visibility, the
    object member is only directly modifiable or callable within the declaring
    class.
</p>

<div class="example"><pre><code lang="php">
class Foo
{
    private $bar = 'bar';

    private function baz() 
    {
        // I can access within my own scope
        return $this->bar;
    }
}

class FooBar extends Foo
{
    public function doThat()
    {
        // These are both illegal
        return $this->bar . $this->baz();
    }
}

$foo = new FooBar();

// These are also both illegal:
echo $foo->bar . $foo->baz();
</code></pre></div>

<p>
    Private visibility is generally of interest for locking down algorithms. 
    For instance, if you know that a particular value or operation must not
    change, even in extending classes, declaring the member private ensures
    that extending classes cannot directly call it. 
</p>

<p>
    At any point, you can redeclare a property in an extending class using 
    equal or more public visibility. The effect of doing so depends on what
    the visibility of the member was in the parent class.
</p>

<ul>
    <li><p>In the case of a <em>public</em> property, if an extending class re-declares with 
        public visibility, any access to the member within the extending class or
        an instance of the extending class will see only the new declaration. </p>

        <div class="example"><pre><code lang="php">
class Foo
{
    public $bar = 'bar';

    public function baz() 
    {
        return $this->bar;
    }
}

class FooBar extends Foo
{
    public $bar = 'foobar';
}

$foo = new FooBar();
echo $foo->bar;   // "foobar"
echo $foo->baz(); // "foobar"
        </code></pre></div>
    </li>

    <li>
        <p>
            In the instance of a <em>protected</em> property, if the extending class 
            re-declares with either public or protected visibility, you get the
            same behavior as public -&gt; public.
        </p>

        <div class="example"><pre><code lang="php">
class Foo
{
    protected $bar = 'bar';

    public function baz() 
    {
        return $this->bar;
    }
}

class FooBar extends Foo
{
    public $bar = 'foobar';
}

$foo = new FooBar();
echo $foo->bar;   // "foobar"
echo $foo->baz(); // "foobar"
        </code></pre></div>
    </li>

    <li>
        <p>
            In the instance of a <em>private</em> property, things get interesting. The
            private value or method will be used for any access made within code
            declared in the parent class, but not overridden in the child. However,
            if the child class overrides any code, the value of the re-declared 
            instance will be used. This is far easier to understand via an example.
        </p>

        <div class="example"><pre><code lang="php">
class Foo
{
    private $bar = 'bar';
    private $baz = 'baz';

    public function baz() 
    {
        return $this->bar;
    }
}

class FooBar extends Foo
{
    protected $bar = 'foobar';
    private $baz = 'foobaz';

    public function myBaz() 
    {
        return $this->bar;
    }

    public function myBaz2()
    {
        return $this->baz;
    }
}

$foo = new FooBar();
echo $foo->baz();    // "bar"
echo $foo->myBaz();  // "foobar"
echo $foo->myBaz2(); // "foobaz"
        </code></pre></div>
    </li>
</ul>

<p>
    My personal takeaway from this is:
</p>

<ul>
    <li>Use <em>public</em> for members that are safe for anything to call.</li>
    <li>Use <em>protected</em> for anything you don't want called from instance methods, 
        not important to the public API (implementation details), and anything you 
        feel is safe for extending classes to muck about with.</li>
    <li>Use <em>private</em> for any important implementation details that could 
        adversely affect execution if overridden by an extending class.</li>
</ul>

<p>
    Those paying attention will note that I skipped <em>final</em>. Actually, I 
    saved that for last. Marking a class or method <em>final</em> tells PHP that
    the class or method may not be extended or re-declared/overridden. At all. I
    lump this with visibility, because it's another way of locking down access to
    an API; marking something <em>final</em> is saying, "you cannot extend this", 
    similar to using <em>private</em>, but without even the possibility of 
    redeclaring.
</p>

<h2>Applied</h2>

<p>
    What got me to thinking about all this was a turn of events with Zend 
    Framework 2. We've had an annotation parser since last summer. <a href="http://ralphschindler.com/">Ralph
    Schindler</a> developed it in order to facilitate automatic discovery of
    injection points for our Dependency Injection container. Classes could
    mark a method with the "Inject" annotation, and the various DI compilers
    would know that that method needed to be injected.
</p>

<div class="example"><pre><code lang="php">
use Zend\Di\Definition\Annotation\Inject;

class Foo
{
    protected $bar;

    /**
     * @Inject()
     * @param  Bar $bar
     * @return void
     */
    public function setBar(Bar $bar)
    {
        $this->bar = $bar;
    }
}

class Bar {}
</code></pre></div>

<p>
    Recently, part of our Forms RFC included a feature to allow creating
    forms and their related input filters by using annotations. Basically,
    this allows developers to hint on their domain entities how specific
    properties should be filtered, validated, and potentially represented
    at the form level.
</p>

<div class="example"><pre><code lang="php">
use Zend\Form\Annotation;

class Foo
{
    /**
     * @Annotation\Filter({"name":"StringTrim"})
     * @Annotation\Validator({"name":"Between","options":{"min":5,"max":20}})
     * @Annotation\Attributes({"type":"range"})
     */
    protected $bar;
}
</code></pre></div>

<p>
    One developer testing the support wanted to use a combination of <a 
    href="http://doctrine-project.org">Doctrine</a> annotations and ZF2 form
    annotations -- that way his entities could also describe validation and
    representation.
</p>

<p>
    I did some work to make this happen, and everybody was happy. Except then
    that same developer went to use that entity with Doctrine, and Doctrine's
    annotation parser started raising exceptions on all the ZF2 annotations.
</p>

<p>
    After some debate, I realized: (a) we were basically just making up syntax
    for our annotations; it'd be better to use an established syntax; but (b)
    we should still retain the ability to use arbitrary syntax, as we can't 
    really know what sorts of annotations developers may already be using.
</p>

<p>
    So, we decided to make our annotation component depend on the annotations
    support in Doctrine\\Common, and to use the annotation syntax they utilize.
    ZF2 would provide some code to make it possible to plug in arbitrary 
    parsers, and use the Doctrine\\Common annotation parser to parse annotations
    officially supported by ZF2.
</p>

<p>
    However, when I went to start making this happen, I ran into immediate issues.
</p>

<p>
    Remember how this post is about visibility? Well, the class I was directly
    interested in, <code>Doctrine\Common\Annotations\DocParser</code>, not only
    contains private members, but is marked <em>final</em>. 
</p>

<p>
    My immediate response was to start dissecting the class, cutting and pasting 
    the bits interesting to my solution into a new class in ZF2. I went down this
    route for several hours, gradually pulling in more and more methods as I
    discovered how far down the rabbit hole I needed to go to accomplish my task.
</p>

<p>
    But at the back of my head, I kept thinking this was a bad idea. If any
    patches ever came in for the original class, I'd need to port them into
    our ZF2 solution. And I couldn't help but think that I'd miss a crucial
    piece.
</p>

<p>
    So I started playing with its public API, to see if there were any shortcuts
    I might be able to take. And there were.
</p>

<p>
    The class has a public <code>parse()</code> method. Based on how Doctrine uses
    the code, I assumed I needed to pass a full PHP docblock in -- which ran
    counter to how I wanted to use the code. I wanted to pass in an annotation
    at a time. But when I looked closer, I realized that the parser didn't
    require a full docblock; any fragment would do.
</p>

<p>
    To make a long story short: I was able to feed the parser a single annotation
    at a time from ZF2's <code>AnnotationScanner</code>. This allowed me to build
    a very simple class that allows registering a set of annotations it can handle,
    and feeding it a single annotation string at a time to decide (a) if it supports
    it, and (b) to parse it and return the associated annotation object.
</p>

<p>
    In sum: because the class in question was marked final and had private 
    members, I found myself forced to think critically about what I wanted
    to accomplish, and then thoroughly understand the public API to see how
    I might accomplish that task without the ability to extend.
</p>

<h2>Conclusions</h2>

<p>
    Doctrine has a policy that encourages <a 
    href="http://en.wikipedia.org/wiki/Poka-yoke"><em>poka-yoke</em></a> solutions:
    code should be executable in a specific way. The policy was developed to
    both aid users (having multiple ways of doing something is often confusing),
    as well as to ease maintenance (fewer extension points means less liklihood
    of developers doing hard-to-debug things in extending code and reporting it
    back to the project). These have led them to heavily use <em>private</em>
    and <em>final</em> visibility.
</p>

<p>
    I've said it before, and I'll say it again: I feel that frameworks and libraries
    should use <em>private</em> and <em>final</em> sparingly. Over the years, I've
    seen code repurposed in simply wondrous ways -- largely due to keeping the
    code as open as possible to extension. I like to enable my users as much as 
    possible.
</p>

<p>
    That said, I can also see Doctrine's argument -- and can see where, while it
    can often be frustrating, it can also lead to potentially more sound and
    elegant solutions.
</p>

<p>
    I'll probably continue shying away from <em>private</em> and <em>final</em> 
    visibility, but I do plan to experiment with it more in the future. What 
    about you?
</p>]]></content:encoded>
      <slash:comments>0</slash:comments>
    </item>
    <item>
      <title>Why Modules?</title>
      <pubDate>Mon, 30 Apr 2012 21:00:00 +0000</pubDate>
      <link>http://mwop.net/blog/2012-04-30-why-modules.html</link>
      <guid>http://mwop.net/blog/2012-04-30-why-modules.html</guid>
      <author>me@mwop.net (Matthew Weier O'Phinney)</author>
      <dc:creator>Matthew Weier O'Phinney</dc:creator>
      <content:encoded><![CDATA[<p>
    I've blogged <a href="/blog/267-Getting-started-writing-ZF2-modules.html">about 
    getting started with ZF2 modules</a>, as well as <a href="/blog/zf2-modules-you-can-use-today.html">about 
    ZF2 modules you can already use</a>. But after fielding some questions recently, 
    I realized I should talk about <em>why</em> modules are important for the 
    ZF2 ecosystem.
</p><h2>History</h2>

<p>
    In the autumn of 2006, <a href="http://andigutmans.blogspot.com/">Andi</a> 
    asked me to spearhead a refactor of the Zend Framework MVC, prior to a 
    stable release. The idea was to address the growing number of issues and
    feature requests, get it well-tested, and document it thoroughly before
    we were ready for a 1.0.0 stable release.
</p>

<p>
    Late in that refactoring, a few folks approached me saying they wanted
    support for "modules". The idea would be to have self-contained directories
    containing discrete MVC functionality -- controllers, views, related models,
    etc. Additionally, they wanted routing to take into account the module, so 
    that we could have controllers with the same "name", but resolving to separate,
    discrete classes.
</p>

<p>
    The "solution" I came up with basically worked, but was quite limited. You 
    could drop modules into a directory, which the front controller would scan
    in order to be able to resolve URLs of the form "/:module/:controller/:action/*". 
    (You could also explicitly define a module in the route configuration if desired).
</p>

<p>
    This mostly worked, until we introduced <code>Zend_Application</code>, at which
    point it fell apart. Why? Because we couldn't quite get bootstrapping to work.
    Bootstrapping the application was easy, but adding modules and their bootstraps,
    and sharing dependencies between all of them, proved to be quite difficult, and 
    we never truly solved it.
</p>

<p>
    Add to this the fact that the only way to get dependencies into controllers was
    via <code>Zend_Registry</code> or the front controller singleton, and the end 
    result were modules that could never truly be shared or simply dropped into an
    application.
</p>

<h2>Modules in ZF2</h2>

<p>
    One of the very first requirements for ZF2, therefor, was to solve the module 
    problem. The goals were fairly simple:
</p>

<blockquote>
    Modules should be re-usable. Developers should be able to drop in 
    third-party modules easily, and immediately utilize them with zero or small 
    amounts of configuration.  Developers should never have to directly alter 
    module code, ever, to get them to work in their applications; customization 
    should be easily achieved via configuration or substitution.
</blockquote>

<p>
    Why?
</p>

<p>
    The goal of any good application framework or content system should be to make
    development of websites as easy as possible. Good systems make it possible to 
    use as little or as much of the framework as needed, and to make extension of 
    the framework trivial. This latter point is perhaps the most important aspect: 
    the quality of any good application ecosystem can typically be judged by the 
    amount and quality of third-party plugins developed for it. 
</p>

<p>
    If your framework is making you write boilerplate code to handle authentication
    for every site you write, or making you write code for common application 
    features such as blogs, comment systems, contact forms, etc., then something 
    is wrong. These sorts of tasks should be done at most a handful of times, and
    <em>shared</em> with the community.
</p>

<p>
    The end-goal is to be able to pull in a handful or more of plugins that do these
    tasks for you, configure them to suit your needs, and then focus on
    building out the functionality that is truly unique to your website.
</p>

<h2>Building Blocks</h2>

<p>
    I'll give a concrete example. In parallel with ZF2 development, I've been 
    rebuilding this very site. I've needed the following pieces:
</p>

<ul>
    <li>A handful of static pages (home page, r&eacute;sum&eacute;, etc.)</li>
    <li>A contact form</li>
    <li>A blog</li>
    <li>Authentication in order to "password protect" a few pages</li>
    <li>A few view helpers (github status, disqus display, etc)</li>
</ul>

<p>
    How much of this functionality is unique to my site, other than the content? Pretty
    much none of it. Ideally, I should be able to find some modules, drop them in, and 
    create some custom view scripts.
</p>

<p>
    Which is what I did. That said, I developed several of the modules, but in some cases,
    such as authentication, I was able to grab modules from elsewhere. The beauty, though,
    is that in the future, I or others can re-use what I've created, and quite easily.
</p>

<p>
    This kind of building-block development makes <em>your</em> job easier as a developer -- 
    and allows you to focus on the bits and pieces that make your site unique. As such, I 
    truly feel that <em><strong>modules are the most important new feature of ZF2</strong></em>.
</p>

<h2>Fin</h2>

<p>
    If you're developing on top of ZF2 today, I have one piece of advice: 
    create and consume modules. Share your modules.  Help make ZF2 a productive, 
    fun, collaborative ecosystem that allows developers to get
    things done and create fantastic new applications.
</p>]]></content:encoded>
      <slash:comments>0</slash:comments>
    </item>
  </channel>
</rss>
