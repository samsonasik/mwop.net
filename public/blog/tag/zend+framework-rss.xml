<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/">
  <channel>
    <title>Tag: zend framework :: phly, boy, phly</title>
    <description>Tag: zend framework :: phly, boy, phly</description>
    <pubDate>Wed, 19 Sep 2012 18:10:00 +0000</pubDate>
    <generator>Zend_Feed_Writer 2.0.2 (http://framework.zend.com)</generator>
    <link>http://mwop.net/blog/tag/zend+framework.html</link>
    <atom:link rel="self" type="application/rss+xml" href="http://mwop.net/blog/tag/zend+framework-rss.xml"/>
    <item>
      <title>ZF2 Modules Quickstart (Screencast)</title>
      <pubDate>Wed, 19 Sep 2012 18:10:00 +0000</pubDate>
      <link>http://mwop.net/blog/2012-09-19-zf2-module-screencast.html</link>
      <guid>http://mwop.net/blog/2012-09-19-zf2-module-screencast.html</guid>
      <author>me@mwop.net (Matthew Weier O'Phinney)</author>
      <dc:creator>Matthew Weier O'Phinney</dc:creator>
      <content:encoded><![CDATA[<p>
One of the exciting features of the newly released Zend Framework 2 is the new
module system.
</p>

<p>
While ZF1 had modules, they were difficult to manage. All resources for all
modules were initialized on each request, and bootstrapping modules was an
onerous task. Due to the difficulties, modules were never truly "plug-and-play",
and thus no ecosystem ever evolved for sharing modules.
</p>

<p>
In Zend Framework 2, we've architected the MVC from the ground up to make
modular applications as easy as possible. Within ZF2, the MVC simply cares about
events and services — and controllers are simply one kind of service. As such,
modules are primarily about telling the MVC about services and wiring event
listeners.
</p>

<p>
To give you an example, in this tutorial, I'll show you how to install the Zend
Framework 2 skeleton application, and we'll then install a module and see how
easy it is to add it to the application and then configure it.
</p><p>
To keep things simple, I'm using a unix-like environment. As such, if you are on
Windows, you may not have the same command-line tools available. If you are in
such a situation, perhaps try this inside a Linux virtual machine.
</p>

<iframe src="http://player.vimeo.com/video/49775540" 
width="500" height="281" frameborder="0" 
webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>
<p><a href="http://vimeo.com/49775540">Zend Framework 2 Module Quickstart</a></p>

<p>
Let's start by creating a new project. We'll execute a few commands to download
a skeleton application archive and extract it.
</p>

<div class="example"><pre><code language="bash">
% mkdir newproject
% cd newproject
% wget https://github.com/zendframework/ZendSkeletonApplication/tarball/master \
    -O ZendSkeletonApplication.tgz
% tar xzf ZendSkeletonApplication.tgz --strip-components=1
</code></pre></div>

<p>
    The Zend Framework skeleton application can be downloaded directly off of
    <a href="https://github.com">GitHub</a>. I'm showing using the download 
    from master, but you can also download a tarball or zipball for individual 
    tags as well. Because the download URL does not include an extension, I use 
    the <code>-O</code> switch to tell <code>wget</code> what filename to save to.
</p>

<p>
    <code>tar</code> has a nice option, `<code>--strip-components</code>`, which allows you to tell it to
    descend a certain number of levels deep into the archive when deflating. Since I
    know the tarball has a top-level directory named after the repository and a
    sha1, I'm simply telling <code>tar</code> to skip that and give me the contents of its
    child directory.
</p>

<p>
    At this point you have the skeleton application, but it has no dependencies 
    — not even Zend Framework itself! Let's rectify that situation. We'll use the
    dependency management tool <a href="https://getcomposer.org/">Composer</a> 
    to do this. We include the Composer phar file within the skeleton 
    application to make this fairly easy. Simply execute the following:
</p>

<div class="example"><pre><code language="bash">
% php composer.phar install
</code></pre></div>

<p>
    You may get a notice indicating that the composer version is older, and to 
    run "self-update"; you can ignore that for now.
</p>

<p>
    If all goes well, you should now have Zend Framework installed. Let's test 
    it out. I'm going to use the built-in web server in PHP 5.4 to demonstrate.
</p>

<div class="example"><pre><code language="bash">
% cd public
% php -S localhost:8080
</code></pre></div>

<p>
    If I browse to <code>http://localhost:8080</code> I should now see the 
    landing page for the skeleton application.
</p>

<img src="/images/screencasts/2012-09-19-zf2-module-screencast-01-zsa.png" style="width: 100%; height: 100%;" />

<p>
    Let's add a module to the application. Many sites require a contact form. 
    I've written one as a module some time ago, and called it <a 
    href="https://github.com/weierophinney/PhlyContact">PhlyContact</a>. To install
    it, I'll edit my project's <code>composer.json</code> and tell it about that 
    dependency:
</p>

<div class="example"><pre><code language="json">
{
    "require": {
        "php": "&gt;=5.3.3",
        "zendframework/zendframework": "dev-master",
        "phly/phly-contact": "dev-master"
    }
}
</code></pre></div>
    
<p>
    I know the name of the component from <a 
    href="http://packagist.org/">http://packagist.org/</a>, and I'm telling
    Composer that I want to use whatever the latest version is on its master 
    branch on GitHub. I happen to also know that PhlyContact requires a dev-master 
    version of Zend Framework, so I'll alter that dependency for now.
</p>

<p>
    Now, we need to tell composer to update our dependencies.
</p>

<div class="example"><pre><code language="bash">
% php composer.phar update
</code></pre></div>
    
<p>
    After executing the command, we should now see that it has installed; this 
    may take a little while.
</p>

<p>
    You need to inform the application about the module. This is so that we don't
    have to perform expensive file-system scanning operations, but also to make it
    explicit in your code what modules you're actually using. Enabling a module is
    usually as easy as adding an entry to <code>config\application.config.php</code>:
</p>

<div class="example"><pre><code language="php">
'modules' => array(
    'Application',
    'PhlyContact',
),
</code></pre></div>

<p>
    This particular module provides some reasonable defaults. In particular, it uses
    a CAPTCHA adapter that doesn't require additional configuration, and assumes
    that you will want to use the default <code>Sendmail</code> mail transport. As such, we can
    simply browse to it now. I happen to know that the module defines a <code>/contact</code>
    end point. Let's fire up our PHP web server again, and browse to that URL.
</p>

<div class="example"><pre><code language="bash">
% cd public
% php -S localhost:8080
</code></pre></div>

<img src="/images/screencasts/2012-09-19-zf2-module-screencast-02-contact.png" style="width: 100%; height: 100%;" />

<p>
    It just works!
</p>

<p>
    One philosophy we have for distributable modules in Zend Framework 2 is 
    that you should not need to touch the code in modules you install in your application.
    Instead, you should be able to configure and override behavior within the
    application configuration or in your application's site-specific modules. Let's
    alter the contact module to:
</p>

<ul>
    <li>first, change the URL it responds to, and</li>
    <li>second, use the "file" mail transport.</li>
</ul>

<p>
    Let's look at the default configuration. I'll browse to
    <code>vendor/phly/phly-contact/config/</code> and look at the <code>module.config.php</code> file.
</p>

<div class="example"><pre><code language="php">
return array(
    'phly_contact' => array(
        'captcha' => array(
            'class' => 'dumb',
        ),
        'form' => array(
            'name' => 'contact',
        ),
        'mail_transport' => array(
            'class' => 'Zend\Mail\Transport\Sendmail',
            'options' => array(
            )
        ),
        'message' => array(
            /*
            'to' => array(
                'EMAIL HERE' => 'NAME HERE',
            ),
            'sender' => array(
                'address' => 'EMAIL HERE',
                'name'    => 'NAME HERE',
            ),
            'from' => array(
                'EMAIL HERE' => 'NAME HERE',
            ),
             */
        ),
    ),

    /* ... */

    'router' => array(
        'routes' => array(
            'contact' => array(
                'type' => 'Literal',
                'options' => array(
                    'route' => '/contact',
                    'defaults' => array(
                        '__NAMESPACE__' => 'PhlyContact\Controller',
                        'controller'    => 'Contact',
                        'action'        => 'index',
                    ),
                ),
                'may_terminate' => true,
                'child_routes' => array(
                    'process' => array(
                        'type' => 'Literal',
                        'options' => array(
                            'route' => '/process',
                            'defaults' => array(
                                'action' => 'process',
                            ),
                        ),
                    ),
                    'thank-you' => array(
                        'type' => 'Literal',
                        'options' => array(
                            'route' => '/thank-you',
                            'defaults' => array(
                                'action' => 'thank-you',
                            ),
                        ),
                    ),
                ),
            ),
        ),
    ),
    /* ... */
);
</code></pre></div>

<p>
    Okay, that's interesting. I can define the captcha and options to use, the 
    name of the contact form, the mail transport I want to use, and even who the email 
    is sent from and who it goes to. In addition, it defines some routes.
</p>

<p>
    I'll create a new file, <code>config/autoload/phly-contact.local.php</code>. This is a
    local configuration file that will not be checked into my version control
    system. Now, let's add some configuration. First, I'll configure my mail
    transport.
</p>

<div class="example"><pre><code language="php">
return array(
    'phly_contact' => array(
        'mail_transport' => array(
            'class'   => 'Zend\Mail\Transport\File',
            'options' => array(
                'path' => 'data/mail/',
            ),
        ),
    ),
);
</code></pre></div>

<p>
    I'm telling the module to use the <code>File</code> mail transport, and telling the transport
    where I want messages written. By default, Zend Framework calls <code>chdir()</code> to
    change directory to the project root, so I can reference a directory relative to
    that. I'm simply going to write to a <code>data/mail/</code> directory. Let's create that,
    and make it world-writable for now to ensure the web server can write to it. (In
    production, you'd only want it writable by the web server user.)
</p>

<div class="example"><pre><code language="bash">
% mkdir -p data/mail
% chmod a+rwX data/mail
</code></pre></div>

<p>
    Now, let's change the base URL the contact form responds to; I want it to
    respond to <code>/contact-us</code>. Another principle of re-usable modules in ZF2 is that
    we recommend creating tree routes for each module, with the root of the tree
    being a literal route. This makes it easy to alter the base for routing, without
    needing to redefine all the routes in the module.
</p>

<p>
    I'll add the following to my local configuration, then. I'll simply override the
    parent route for my module, named "contact", and point it at a different URL.
</p>

<div class="example"><pre><code language="php">
'router' => array(
    'routes' => array(
        'contact' => array(
            'options' => array(
                'route' => '/contact-us',
            ),
        ),
    ),
),
</code></pre></div>

<p>
    Let's see if all this worked! Once again, I'll fire up PHP's built-in web
    server.
</p>

<div class="example"><pre><code language="bash">
% cd public
% php -S localhost:8080
</code></pre></div>

<p>
    Now, let's browse to <code>http://localhost:8080/contact-us</code> -- looks good! Just as an
    experiment, let's try the previously configured URL,
    <code>http://localhost:8080/contact</code>. We get a 404 now!
</p>

<img src="/images/screencasts/2012-09-19-zf2-module-screencast-03-config.png" style="width: 100%; height: 100%;" />
<img src="/images/screencasts/2012-09-19-zf2-module-screencast-04-404.png" style="width: 100%; height: 100%;" />

<p>
    Now, let's submit the form. I'll fill in some information; it's asking for my
    email address, a subject line, and a message, as well as for me to solve a
    simple CAPTCHA. Once I've done all that, I can send it.
</p>

<p>
    If all is well, we should now have a mail file in our data directory. Let's
    check.
</p>

<div class="example"><pre><code language="bash">
% ls -l data/mail/
</code></pre></div>

<p>
    And now let's look at it.
</p>

<div class="example"><pre><code language="bash">
% cat data/mail/ZendMail_1347989389_1009740165.tmp
Date: Tue, 18 Sep 2012 12:29:49 -0500
From: me@mwop.net
Reply-To: me@mwop.net
Subject: [Contact Form] Suspense!

Suspenseful, isn't it?
</code></pre></div>
    
<p>
    Looks good!
</p>

<p>
    Zend Framework 2 provides a wonderful modular architecture that will enable an
    ecosystem of 3rd party modules that should save you time and energy when
    developing your applications. I've demonstrated a simple one, a contact form,
    but many, many more already exist, and with a stable release now available, you
    should see that number grow. This is truly a wonderful step forward for
    developers, and I hope you find it as exciting as I do.
</p>]]></content:encoded>
      <slash:comments>0</slash:comments>
    </item>
    <item>
      <title>On Microframeworks</title>
      <pubDate>Fri, 17 Aug 2012 16:00:00 +0000</pubDate>
      <link>http://mwop.net/blog/2012-08-17-on-microframeworks.html</link>
      <guid>http://mwop.net/blog/2012-08-17-on-microframeworks.html</guid>
      <author>me@mwop.net (Matthew Weier O'Phinney)</author>
      <dc:creator>Matthew Weier O'Phinney</dc:creator>
      <content:encoded><![CDATA[<p>
    A number of months ago, <a href="http://funkatron.com/">Ed Finkler</a> 
    started a discussion in the PHP community about &#8220;<a 
    href="http://microphp.org/">MicroPHP</a>&#8221;; to summarize, the movement
    is about:
</p>

<ul>
    <li>Building small, single-purpose libraries.</li>
    <li>Using small things that work together to solve larger problems.</li>
</ul>

<p>
    I think there are some really good ideas that have come out of this, and 
    also a number of questionable practices<sup><a name="t1" href="#f1">1</a></sup>.
</p>

<p>
    One piece in particular I've focussed on is the concept of so-called 
    &#8220;microframeworks&#8221;.
</p><h2>What is a microframework?</h2>

<p>
    PHP has had microframeworks for quite some time<sup><a name="t2" href="#f2">2</a></sup>, 
    though I only really first saw the term being used around 3 years ago. The 
    &#8220;grand-daddy&#8221; of modern-day microframeworks can actually be 
    traced to Ruby, however, and specifically 
    <a href="http://www.sinatrarb.com">Sinatra</a>.
</p>

<p>
    Sinatra is not so much a framework as it is a domain-specific language (DSL).
    The language and structure it created, however, have been re-created in the
    vast majority of microframeworks you see currently in the PHP arena. 
    Specifically, it describes how to map HTTP request methods and paths to the
    code that will handle them. It borrowed route matching ideas from
    <a href="http://rubyonrails.org/">Ruby on Rails</a>, and relied on the fact 
    that Ruby uses the last value of a block as the return value.
</p>

<p>
    As some simple examples:
</p>

<div class="example"><pre><code language="ruby">
get '/hello/:name' do |n|
    "Hello #{n}!"
end

post '/address'
    # create address
end

put '/address/:id' |i|
    # update address
end

get '/feed.?:format?', :provides => ['rss', 'atom', 'xml'] do
    builder :feed
end
</code></pre></div>

<p>
    The language is expressive, and allows the developer to focus on two things:
</p>

<ul>
    <li>What are the specific entry points (URIs) for the application?</li>
    <li>What needs to be done for each specific entry point?</li>
</ul>

<p>
    I'd argue that the above two points are the defining characteristics of 
    modern microframeworks. Typically, the entry points are given the term
    &#8220;routing &#8221;, and the second corresponds to &#8220;controllers&#8221;.
</p>

<h2>PHP implementations</h2>

<p>
    I'd argue one of the earliest microframework implementations, though it 
    wasn't termed as such, was <a href="http://dev.horde.org/routes/">Horde 
    Routes</a><sup><a name="t3" href="#f3">3</a></sup> (which was itself inspired by <a 
    href="http://routes.readthedocs.org/en/latest/index.html">Python Routes</a>, 
    in turn inspired by the Rails routing system, like Sinatra). It follows
    the two principles I outlined above: it allows defining routes (entry points),
    and mapping them to controllers. Controllers for Routes are simply classes, 
    and a route must provide both a controller and an action in the match, with 
    the latter corresponding to a method on the controller class.
</p>

<p>
    Since around 2009, I've seen an increasing number of new PHP microframeworks<sup><a name="t4" href="#f4">4</a></sup>
    that follow in the steps of Sinatra and Horde. In the various 
    implementations I've looked at, instead of using a DSL, the authors have all
    opted for either a procedural or OOP interface. Starting with PHP 5.3, most
    authors have also primarily targetted any PHP callable as a controller, 
    favoring callbacks specifically. The fundamental ideas remain the same as 
    Sinatra, however:
</p>

<div class="example"><pre><code language="php">
/* Procedural */
get('/hello/:name', function ($n) {
    return "Hello {$n}!";
});

post('/address', function () {
    // create address
});

put('/address/:id' function ($i) {
    // update address
});

get('/feed.?:format?', function($feed, $format) {
    return builder($feed, $format);
});

/* OOP */
$app->get('/hello/:name', function ($n) {
    return "Hello {$n}!";
});

$app->post('/address', function () {
    // create address
});
end

$app->put('/address/:id', function ($i) {
    // update address
});

$app->get('/feed.?:format?', function ($feed, $format) use ($app) {
    return $app->builder($feed, $format);
})->constraints(['format' => '/^(rss|atom|xml)$/']);
</code></pre></div>

<p>
    One key difference I've witnessed in the implementations is surrounding
    how route matches are passed to the callback. In the examples above, they
    are passed as individual arguments to the handler. Some, however, opt for
    an approach more like Sinatra, which passes a single "params" argument into
    the scope of the handler. This approach tends to be more expedient both 
    from an implementation standpoint as well as a performance standpoint, as
    it does not require reflection to determine name and position of arguments,
    and makes handling wildcard arguments simpler. I've seen this latter 
    approach handled several ways:
</p>

<div class="example"><pre><code language="php">
// Pass in route match parameters as an argument.
$app->get('/feed.:format', function ($params) {
    $format = $params['format'];
});

// Pass in the $app instance, and retrieve route 
// match parameters from it.
$app->get('/feed.:format', function ($app) {
    $format = $app->params('format');
});

// Curry in the $app instance when desired, and 
// retrieve route match parameters from it.
$app->get('/feed.:format', function () use ($app) {
    $format = $app->params('format');
});
</code></pre></div>

<p>
    Another difference I've seen is in how route constraints, defaults, and
    names are handled. The most elegant solutions usually allow chaining
    method calls in order to alter this data:
</p>

<div class="example"><pre><code language="php">
$app->get('/feed.:format', function ($app) {
  })->constraints(['format' => '/^(atom|xml|json)$/'])
    ->name('feed');
</code></pre></div>

<p>
    One common feature I've seen is the ability to generate URLs based on the 
    defined routes. Most commonly, this is a function or method 
    <code>urlTo()</code>, which takes a route name, and an associative array
    of replacements.
</p>

<div class="example"><pre><code language="php">
echo $app->urlTo('feed', ['format' => 'atom']);
</code></pre></div>

<p>
    That's it in a nutshell: the ability to match HTTP request methods and
    path information, and map it to controllers/handlers, and to generate
    URLs based on those present in the application.
</p>

<h2>What are they good for?</h2>

<p>
    In my research and experience, microframeworks have three typical use cases:
</p>

<ol>
    <li>
        <b>Prototyping.</b> Because of their simplicity, microframeworks are 
        fantastic for prototyping a basic website. Very often, in the early
        stages of a site, you have a limited number of pages, and most often
        simply need to render a template with limited variable substitutions.
        Microframeworks are a perfect fit for this.
    </li>

    <li>
        <b>APIs</b>. API needs are usually quite well-defined, and often 
        involve a small, finite number of URLs. The logic required is usually
        already encapsulated in business objects, so the application layer
        is simply for filtering and returning a representation. Microframeworks
        again offer a nice fit.
    </li>

    <li>
        <b>Small, mostly static sites</b>. Similar to the first point, if you
        know the site will be relatively small and mostly static, then the
        minimal overhead of a microframework is often a good fit.
    </li>
</ol>

<h2>Where do microframeworks fail?</h2>

<p>
    Because of the rather declarative nature of microframeworks, and the
    typically 1:1 mapping of a route to a controller, microframeworks do
    not tend to promote code re-use. Additionally, this extends to how
    microframework applications are organized: usually, there are no clear
    guidelines on how to organize routes and controllers, much less separate
    them into multiple files. This can lead to maintenance issues as the
    application grows, as well as logistical issues whenever you need to 
    add new routes and controllers (do they go at the top, or bottom? are
    there other routes that could potentially match as well? etc.). 
</p>

<p>
    Additionally, though many frameworks offer ways to alter the workflow
    of the application either via hooks, events, or &#8220;middleware&#8221;<sup><a name="t5" href="#f5">5</a></sup>,
    most of these are limited in scope, often non-reusable, and often
    non-stackable. As such, comprehensive manipulation of the application
    workflow is out of reach.
</p>

<p>
    One other area that is overlooked, however, is one I find curious, 
    particularly in light of the MicroPHP movement: so much of the
    underlying plumbing is basically the same, yet every microframework
    re-implements it. Specifically:
</p>

<ul>
    <li>
        Routing is basically the same across most implementations, following the
        same basic specifications outlined in Rails. There are very few differences
        in the public APIs.
    </li>

    <li>
        Request and Response object abstraction is largely the same as well, 
        providing access to query/post/cookie/session/etc. parameters through
        roughly equivalent APIs.
    </li>

    <li>
        Many implement their own view layers.<sup><a name="t6" href="f6">6</a></sup>
    </li>
</ul>

<p>
    Most of this code should be considered commodity code at this point. There are 
    several outstanding view layers and templating engines available (Smarty, Twig,
    Savant, Zend\View). Standalone routing libraries exist such as Horde Routes,
    and even those bundled with frameworks are often available separately via
    Composer or Pyrus; the same is true with Request and Response object 
    abstraction. It seems to me that a few microframework authors should be 
    working on abstracting these concerns, and then focussing their efforts on
    differentiators in their own microframeworks.
</p>

<h2>An experiment</h2>

<p>
    Building on my last point, I looked at the APIs of <a 
    href="http://limonade-php.github.com/">Limonade</a> and <a 
    href="http://www.slimframework.com/">Slim Framework</a>, and built up a 
    specification for a microframework. I then matched as many pieces of it 
    as possible to existing components in <a 
    href="http://packages.zendframework.com/">ZF2</a>, and started building.
</p>

<p>
    In a matter of a few hours, I had written up a complete test suite<sup><a name="t7" href="#f7">7</a></sup> 
    and all code for a microframework, featuring the following (this is 
    basically the testdox output from the unit test suite):
</p>

<ul>
    <li>Lazy loads request</li>
    <li>Lazy loads response</li>
    <li>Request is injectible</li>
    <li>Response is injectible</li>
    <li>Halt should raise halt exception</li>
    <li>Response should contain status provided to halt</li>
    <li>Response should contain message provided to halt</li>
    <li>Stop should raise halt exception</li>
    <li>Response should remain unaltered after stop</li>
    <li>Redirect should raise halt exception</li>
    <li>Redirect should set 302 response status by default</li>
    <li>Redirect should set response status based on provided status code</li>
    <li>Redirect should set location header</li>
    <li>Map creates a segment route when provided with a string route</li>
    <li>Map can receive a route object</li>
    <li>Passing invalid route raises exception</li>
    <li>Map can receive a callable</li>
    <li>Passing invalid controller to route does not immediately raise exception</li>
    <li>Accessing invalid controller raises exception</li>
    <li>Passing invalid method to route via method raises exception</li>
    <li>Can set methods route responds to singly</li>
    <li>Can set methods route responds to as array</li>
    <li>Can set methods route responds to as multiple arguments</li>
    <li>Can specify additional method types to respond to</li>
    <li>Can specify route name</li>
    <li>Adding route using method type creates route that responds to that method type</li>
    <li>Running with no matching routes raises page not found exception</li>
    <li>Routing sets list of named routes</li>
    <li>Routing sets lists of routes by method</li>
    <li>Successful routing dispatches controller</li>
    <li>Unsuccessful routing triggers 404 event</li>
    <li>Calling halt triggers halt event</li>
    <li>Invalid controller triggers 501 event</li>
    <li>Exception raised in controller triggers 500 event</li>
    <li>Can pass to next matching route</li>
    <li>Url for helper assembles url based on name provided</li>
    <li>Url for helper assembles url based on name and params provided</li>
    <li>Url for helper assembles url based on current route match when no name provided</li>
    <li>Composes logger instance by default</li>
    <li>Can inject specific logger instance</li>
    <li>Mustache view is used by default</li>
    <li>Can inject alternate view instance</li>
    <li>Render renders a template to the response</li>
    <li>View model returns mustache view model by default</li>
    <li>Subsequent calls to view model return separate instances</li>
    <li>Can provide view model prototype</li>
</ul>

<p>
    I utilized ZF2's routing library from its MVC component, the request and response
    objects from its HTTP component, its Log component, and the Session component. These
    had a few other dependencies, but nothing terribly onerous.
</p>

<p>
    For the view, I used my own <a 
    href="http://weierophinney.github.com/phly_mustache">phly_mustache</a>, and provided
    a basic "view model" implementation that receives the application instance, thus
    allowing the ability to call application helpers (such as url generation).
</p>

<p>
    To make installation simple, I used <a href="http://getcomposer.org">Composer</a>
    to manage my dependencies on specific ZF2 components and for phly_mustache. The
    microframework contains only the code it needs to get its work done, leveraging
    the work of others whenever possible.
</p>

<p>
    This post is not meant as a way to announce a new microframework, however.<sup><a name="t8" href="#f8">8</a></sup>
    The point of the experiment was to prove something: microframeworks are
    trivially easy to write, <em>particularly if you follow the principals of 
    MicroPHP, and re-use existing code</em>. Just because code comes from a framework
    or a third-party library does not make it suspect or inferior; in fact,
    whenever possible, you should leverage such code so you can focus on 
    <em>writing awesome applications</em>.
</p>

<h2>Lessons learned</h2>

<p>
    I really like microframeworks for specific problems: prototyping, APIs, and 
    small, simple sites. I think they are ideally suited for these tasks. That
    said, I'd love to see some solid libraries targetting the fundamental, shared
    aspects of these efforts: routing, request and response abstraction, etc.
    With dependency management tools such as Composer and Pyrus, having required
    dependencies is not a big deal anymore, and re-use should be encouraged.
</p>

<p>
    Also, writing a microframework is an excellent coding exercise. It helps a 
    developer appreciate the complexities of abstraction while limiting the number
    of moving parts. I highly recommend it as an exercise -- but do it using 
    available components, and be prepared to throw it away and instead collaborate
    with others, or adopt something which better solves both the problems you have
    and the problems you anticipate.
</p>

<p>
    In sum: <em>Use the right tool for the job</em>. If you foresee expanding 
    requirements in your project's future, you may want to evaluate a full-stack
    framework,<sup><a name="t9" href="#f9">9</a></sup> or consider building something 
    robust that suits your specific project's needs. Use microframeworks where
    and when they make sense.
</p>

<h4>Afterword</h4>

<p>
    I'm well aware that Fabien Potencier has written
    <a href="http://fabien.potencier.org/article/50/create-your-own-framework-on-top-of-the-symfony2-components-part-1">a comprehensive series of posts on creating a microframework using Symfony 2
    components</a>. I deliberately chose not to read them until (a) ZF2 was 
    almost ready to release, and (b) I'd had a chance to formulate my own
    opinions on microframeworks. They're an excellent read, however, and show a 
    nice progression of development from flat PHP to a fully functional 
    microframework; click the link and see for yourself.
</p>

<h4>Footnotes</h4>

<ul>
    <li>
        <sup><a name="f1" href="#t1">1</a></sup> In particular, I feel that the movement 
        (a) disparages components from larger libraries simply because they
        originate from a larger library, and (b) distrust any code that has 
        additional dependencies. This latter I find truly puzzling, as I'd 
        think it fits the idea of &#8220;use small things that work together to 
        solve larger problems.&#8221; If the code solves a particular problem
        and allows you to focus on a larger problem, where it originates and 
        the number of dependencies should not be an issue.
    </li>

    <li>
        <sup><a name="f2" href="#t2">2</a></sup> In fact, my first foray into MVC in PHP 
        was writing a clone of Perl's <a href="http://cgi-app.org/">CGI::Application</a>,
        which in many ways is also a microframework.
    </li>

    <li>
        <sup><a name="f3" href="#t3">3</a></sup> Trivia: Both authors of Horde Routes 
        worked at Zend when I first started at the company, and Mike Naberezny
        wrote the very first lines of code for Zend Framework.
    </li>

    <li>
        <sup><a name="f4" href="#t4">4</a></sup> I swear, you see new ones on Github daily,
        and on <a href="http://phpdeveloper.org/">PHP Developer</a> at least
        once a week.
    </li>

    <li>
        <sup><a name="f5" href="#t5">5</a></sup> <a href="http://www.slimframework.com">Slim</a>
        has this concept. Basically, any callables placed between the route 
        string and the last callable when defining a route -- i.e., the &#8220;middle&#8221;
        arguments, and thus middleware -- will be executed in order prior to 
        attempting to execute the controller.
    </li>

    <li>
        <sup><a name="f6" href="#t6">6</a></sup> <a href="http://www.slimframework.com">Slim</a>
        is an outlier here, as it utilizes <a href="http://twig.sensiolabs.org/">Twig</a>
        by default.
    </li>

    <li>
        <sup><a name="f7" href="#t7">7</a></sup> I'm sure that my TDD experiment will warm the
        soul of <a href="http://www.littlehart.net/atthekeyboard/" alt="Chris 
        Hartjes">the Grumpy Programmer</a>.
    </li>

    <li>
        <sup><a name="f8" href="#t8">8</a></sup> That said, if you want to look at the results, 
        you can <a href="http://github.com/weierophinney/phlyty">find Phlyty on Github</a>.
    </li>

    <li>
        <sup><a name="f9" href="#t9">9</a></sup> As you may guess, I'm biased towards <a 
        href="http://framework.zend.com/">Zend Framework</a>. However, you should always
        carefully evaluate a framework against your project's needs.
    </li>
</ul>]]></content:encoded>
      <slash:comments>0</slash:comments>
    </item>
    <item>
      <title>ZF2's New Controller::init()</title>
      <pubDate>Tue, 31 Jul 2012 02:00:00 +0000</pubDate>
      <link>http://mwop.net/blog/2012-07-30-the-new-init.html</link>
      <guid>http://mwop.net/blog/2012-07-30-the-new-init.html</guid>
      <author>me@mwop.net (Matthew Weier O'Phinney)</author>
      <dc:creator>Matthew Weier O'Phinney</dc:creator>
      <content:encoded><![CDATA[<p>
    In Zend Framework 1, controller's had an <code>init()</code> method, which
    was called after the controller was instantiated. The reason for it was to
    encourage developers not to override the constructor, and thus potentially
    break some of the functionality (as a number of objects were injected via
    the constructor). <code>init()</code> was useful for doing additional object
    initialization.
</p>

<div class="example"><pre><code language="php">
class MyController extends Zend_Controller_Action
{
    public function init()
    {
        // do some stuff!
    }
}
</code></pre></div>

<p>
    But this feature is missing from ZF2; how can we accomplish this sort of
    pattern?
</p><h2>Constructor Overriding</h2>

<p>
    Why didn't we add the <code>init()</code> method in Zend Framework 2?
    Because we don't have a constructor by default, and also to reduce overall
    method calls; if a controller won't be overriding the method, there's no
    reason to make the call in the first place.  So, that means, in ZF2, unlike
    ZF1, to do the same thing, you can simply define a constructor in your
    controller:
</p>

<div class="example"><pre><code language="php">
use Zend\Mvc\Controller\AbstractActionController;

class MyController extends AbstractActionController
{
    public function __construct()
    {
        // do some stuff!
    }
}
</code></pre></div>

<p>
    Except there's one specific and often-needed use case where this fails: if
    you want to wire listeners to the controller's event manager.
</p>

<h2>Events</h2>

<p>
    Why does this fail with the event manager? Because when we're in the
    constructor, we don't yet have an <code>EventManager</code> instance!
    The event manager instance is injected after instantiation. As such, we
    need to attach to it once we know we have an event manager. Which is...
    when it's set. This can be done very simply by overriding the
    <code>setEventManager()</code> method. In the next example, we'll
    define a listener for the "dispatch" event that redirects if certain
    criteria is not met.
</p>

<div class="example"><pre><code language="php">
use Zend\EventManager\EventManagerInterface;
use Zend\Mvc\Controller\AbstractActionController;

class MyController extends AbstractActionController
{
    public function setEventManager(EventManagerInterface $events)
    {
        parent::setEventManager($events);

        $controller = $this;
        $events->attach('dispatch', function ($e) use ($controller) {
            $request = $e->getRequest();
            $method  = $request->getMethod();
            if (!in_array($method, array('PUT', 'DELETE', 'PATCH'))) {
                // nothing to do
                return;
            }

            if ($controller->params()->fromRoute('id', false)) {
                // nothing to do
                return;
            }

            // Missing identifier! Redirect.
            return $controller->redirect()->toRoute(/* ... */);
        }, 100); // execute before executing action logic
    }
}
</code></pre></div>

<p>
    The beauty of this is that we only override when we need to, and we override
    in the specific context we're trying to influence. Additionally, we're only
    registering the event listener if this particular controller is instantiated
    -- which helps reduce our overall number of listeners, and thus shapes our
    call graph based on the controller invoked.
</p>

<h2>Other dependencies</h2>

<p>
    As you'll likely note, the event manager is not the only case where you may
    need to follow a similar pattern. Any time your initialization logic may be
    based on a dependency, you'll want to override the setter in which that
    dependency is injected.
</p>

<p>
    <em>Got any ZF2 tips of your own to share? Blog them!</em>
</p>

<h2>Update: ServiceManager</h2>

<p>
    A few folks in the comments were remarking that the felt that omitting the
    <code>init()</code> method makes it harder for developers to identify when
    and where to do initialization logic, particularly when you may be working
    with multiple dependencies.
</p>

<p>
    Which made me realize there's another place I missed, one that's potentially
    even better suited to initialization: the <code>ServiceManager</code>.
</p>

<p>
    Basically, if you find yourself having complex initialization needs, or
    many dependencies, you should be building a factory for your controller, and
    wiring it to the <code>ServiceManager</code>. This can happen in one of
    several places, but my preference is in my module's <code>Module</code>
    class, in the <code>getControllerConfig()</code> method. This method returns
    configuration for the controller manager that instantiates, validate, and
    injects controllers; it's basically a type of <code>ServiceManager</code>,
    and, in fact, has access to the main application's instance. I'll take the
    previous example, and wire it in the context of a factory:
</p>

<div class="example"><pre><code language="php">
namespace My

use Zend\EventManager\EventManagerInterface;

class Module
{
    /*
     * Assume some other methods, such as getConfig(), etc.
     * Also assume that a route will return a controller named
     * "My\Controller\My" which we assume will reference a controller
     * within our current namespace.
     */

    public function getControllerConfig()
    {
        return array('factories' => array(
            'My\Controller\My' => function ($controllers) {
                $services   = $controllers->getServiceLocator();
                $controller = new Controller\MyController();
                $events     = $services->get('EventManager')

                $events->attach('dispatch', function ($e) use ($controller) {
                    $request = $e->getRequest();
                    $method  = $request->getMethod();
                    if (!in_array($method, array('PUT', 'DELETE', 'PATCH'))) {
                        // nothing to do
                        return;
                    }

                    if ($controller->params()->fromRoute('id', false)) {
                        // nothing to do
                        return;
                    }

                    // Missing identifier! Redirect.
                    return $controller->redirect()->toRoute(/* ... */);
                }, 100); // execute before executing action logic

                $controller->setEventManager($events);
                return $controller;
            };
        ));
    }
}
</code></pre></div>

<p>
    The above will create the controller, grab an event manager instance,
    attach the listener, and then inject the event manager into the controller.
    If you wanted to do more complex work, you definitely could -- and this
    would be the place to do it.
</p>]]></content:encoded>
      <slash:comments>0</slash:comments>
    </item>
    <item>
      <title>ZF2 Forms in Beta5</title>
      <pubDate>Thu, 05 Jul 2012 20:40:00 +0000</pubDate>
      <link>http://mwop.net/blog/2012-07-02-zf2-beta5-forms.html</link>
      <guid>http://mwop.net/blog/2012-07-02-zf2-beta5-forms.html</guid>
      <author>me@mwop.net (Matthew Weier O'Phinney)</author>
      <dc:creator>Matthew Weier O'Phinney</dc:creator>
      <content:encoded><![CDATA[<p>
    Forms are a nightmare for web development. They break the concept of 
    separation of concerns:
</p>

<ul>
    <li>They have a <em>display</em> aspect (the actual HTML form)</li>
    <li>They have a <em>validation</em> aspect</li>
    <li>And the two mix, as you need to display validation error messages.</li>
</ul>

<p>
    On top of that, the submitted data is often directly related to your domain
    models, causing more issues:
</p>

<ul>
    <li>Not all elements will have a 1:1 mapping to the domain model -- 
    buttons, CSRF protection, CAPTCHAs, etc. usually are application-level 
    concerns, but not domain issues.</li>
    <li>Names valid for your domain model may not be valid names for HTML 
    entities.</li>
</ul>

<p>
    Add to this that the validation logic may be re-usable outside of a forms 
    context, and you've got a rather complex problem.
</p><h2>Forms in ZF2</h2>

<p>
    Starting in 2.0.0beta4, we offerred a completely rewritten Form component. 
    In fact, it's not just a Form component -- a new component, InputFilter, 
    was also added. InputFilter is a component that provides re-usable validation
    and normalization logic, and can be used with forms or your domain model.
    The Form component is basically a bridge between domain models/validation 
    and the view layer.
</p>

<p>
    However, this means a bit more complexity for the end-user. You now must:
</p>

<ul>
    <li>Create your form, which consists of elements and fieldsets.</li>
    <li>Create an input filter, consisting of inputs.</li>
    <li>Inform the form of the input filter.</li>
</ul>

<p>
    It's a bit of work. And there's more: we wanted to simplify the process of
    getting your validated values into your domain objects. For this, we added
    a concept of <em>hydrators</em>, which map the validated form values to
    an object you <em>bind</em> to the form. Now you have <em>three</em> pieces
    to keep track of -- form (and its elements), input filter (and its inputs),
    and a hydrator.
</p>

<p>
    So, a few developers had an idea: use annotations on the domain model objects
    to define these items, letting you keep it all in one place.
</p>

<p>
    While I'm not normally a fan of annotations, I immediately saw the appeal 
    in this particular situation.
</p>

<h2>An Example</h2>

<p>
    Let's consider a very simple example. The following domain object represents
    data for a user, and includes a variety of elements we'd represent in a form.
</p>

<div class="example"><pre><code language="php">
namespace MyVendor\Model;

use Zend\Form\Annotation;

/**
 * @Annotation\Hydrator("Zend\Stdlib\Hydrator\ObjectProperty")
 * @Annotation\Name("user")
 */
class User
{
    /**
     * @Annotation\Attributes({"type":"text" })
     * @Annotation\Validator({"type":"Regex","options":{"regex":"/^[a-zA-Z][a-zA-Z0-9_-]{1,19}/"}})
     * @Annotation\Options({"label":"Username:"})
     */
    public $username;

    /**
     * @Annotation\Required(false)
     * @Annotation\Attributes({"type":"text" })
     * @Annotation\Options({"label":"Your full name:"})
     */
    public $fullname;

    /**
     * @Annotation\Type("Zend\Form\Element\Email")
     * @Annotation\Options({"label":"Your email address:"})
     */
    public $email;

    /**
     * @Annotation\Type("Zend\Form\Element\Url")
     * @Annotation\Options({"label":"Your home page:"})
     */
    public $uri;
}
</code></pre></div>

<p>
    So, what does the above do?
</p>

<ul>
    <li>The "name" annotation gives a form or element a specific name.</li>
    <li>The "attributes" annotation indicates what attributes to compose into 
        the form or element.</li>
    <li>Similarly, the "options" annotation specifies options to compose into
        an element. These typically include the label, but may include other
        configuration that doesn't have an exact analog in the HTML attributes.</li>
    <li>The "validator" annotation indicates a validator to compose for the 
        input for a given element. We also ship a "filter" annotation.</li>
    <li>The "type" annotation indicates a class to use for that particular form 
        or element. In the specific cases used above, the elements actually 
        provide default filters and validators, simplifying setup further!</li>
    <li>Last, but not least, the "hydrator" annotation indicates a 
        <code>Zend\Stdlib\Hydrator</code> implementation to use to relay data 
        between the form and the object.  I'll cover this more shortly.</li>
</ul>

<p>
    So, let's now turn to creating a form and consuming it.
</p>

<div class="example"><pre><code language="php">
use MyVendor\Model\User;
use Zend\Form\Annotation\AnnotationBuilder;

$user    = new User();
$builder = new AnnotationBuilder();
$form    = $builder->createForm($user);

$form->bind($user);
$form->setData($dataFromSomewhere);
if ($form->isValid()) {
    // $user is now populated!
    echo $form->username;
    return;
} else {
    // probably need to render the form now.
}
</code></pre></div>

<p>
    You're not quite done, really -- most likely, you'll need to include a 
    submit button of some sort, and it's always good practice to include a
    token to prevent CSRF injections. But with the above, you've accomplished
    the major headaches of setting up a form -- and using the data -- with 
    minimal fuss.
</p>


<h2>Much more!</h2>

<p>
    The form support in ZF2 offers a ton of other features, some of which
    are not specific to forms even.
</p>

<ul>
    <li>
        <p>
            ZF2 supports a variety of hydration strategies, which allow you to pass
            data to and from objects. The example above uses one that suggests a 1:1
            mapping between the inputs and the object properties; other strategies
            include using <code>ArrayObject</code>, using class mutator 
            methods, and more.
        </p>

        <p>
            At this point, you can hydrate an entire form, as well as individual
            fieldsets!
        </p>
    </li>

    <li>
        <p>
            You can provide custom annotations. While this feature is not 
            documented yet, you can tell the <code>AnnotationBuilder</code> 
            about additional annotation classes, as well as provide listeners
            for those annotations so that they can interact with the form
            construction process. As an example, one contributor has already
            used these features to utilize <a 
            href="http://doctrine-project.org">Doctrine</a> annotations to
            inform the builder about the name of a property, as well as
            indicate validators. (Side note: ZF2 now uses Doctrine's annotation
            syntax and parser by default.)
        </p>
    </li>

    <li>
        <p>
            There are a number of features targetting collections, so that
            your client-side code can return arbitrary numbers of a specific
            fieldset type (e.g., collecting addresses for an applicant), and
            the form will be able to validate each. You can <a 
            href="http://www.michaelgallego.fr/blog/?p=190">read more about 
            those features from the author himself</a>.
        </p>
    </li>
</ul>

<p>
    These features are all now available starting with the newly released 
    2.0.0beta5 version, which you can grab from the <a 
    href="http://packages.zendframework.com/">ZF2 packages site</a>. 
</p>

<p>
    I'm really excited with the solutions we've created in ZF2, and even more
    excited to see people put them to use!
</p>]]></content:encoded>
      <slash:comments>0</slash:comments>
    </item>
    <item>
      <title>Why Modules?</title>
      <pubDate>Mon, 30 Apr 2012 21:00:00 +0000</pubDate>
      <link>http://mwop.net/blog/2012-04-30-why-modules.html</link>
      <guid>http://mwop.net/blog/2012-04-30-why-modules.html</guid>
      <author>me@mwop.net (Matthew Weier O'Phinney)</author>
      <dc:creator>Matthew Weier O'Phinney</dc:creator>
      <content:encoded><![CDATA[<p>
    I've blogged <a href="/blog/267-Getting-started-writing-ZF2-modules.html">about 
    getting started with ZF2 modules</a>, as well as <a href="/blog/zf2-modules-you-can-use-today.html">about 
    ZF2 modules you can already use</a>. But after fielding some questions recently, 
    I realized I should talk about <em>why</em> modules are important for the 
    ZF2 ecosystem.
</p><h2>History</h2>

<p>
    In the autumn of 2006, <a href="http://andigutmans.blogspot.com/">Andi</a> 
    asked me to spearhead a refactor of the Zend Framework MVC, prior to a 
    stable release. The idea was to address the growing number of issues and
    feature requests, get it well-tested, and document it thoroughly before
    we were ready for a 1.0.0 stable release.
</p>

<p>
    Late in that refactoring, a few folks approached me saying they wanted
    support for "modules". The idea would be to have self-contained directories
    containing discrete MVC functionality -- controllers, views, related models,
    etc. Additionally, they wanted routing to take into account the module, so 
    that we could have controllers with the same "name", but resolving to separate,
    discrete classes.
</p>

<p>
    The "solution" I came up with basically worked, but was quite limited. You 
    could drop modules into a directory, which the front controller would scan
    in order to be able to resolve URLs of the form "/:module/:controller/:action/*". 
    (You could also explicitly define a module in the route configuration if desired).
</p>

<p>
    This mostly worked, until we introduced <code>Zend_Application</code>, at which
    point it fell apart. Why? Because we couldn't quite get bootstrapping to work.
    Bootstrapping the application was easy, but adding modules and their bootstraps,
    and sharing dependencies between all of them, proved to be quite difficult, and 
    we never truly solved it.
</p>

<p>
    Add to this the fact that the only way to get dependencies into controllers was
    via <code>Zend_Registry</code> or the front controller singleton, and the end 
    result were modules that could never truly be shared or simply dropped into an
    application.
</p>

<h2>Modules in ZF2</h2>

<p>
    One of the very first requirements for ZF2, therefor, was to solve the module 
    problem. The goals were fairly simple:
</p>

<blockquote>
    Modules should be re-usable. Developers should be able to drop in 
    third-party modules easily, and immediately utilize them with zero or small 
    amounts of configuration.  Developers should never have to directly alter 
    module code, ever, to get them to work in their applications; customization 
    should be easily achieved via configuration or substitution.
</blockquote>

<p>
    Why?
</p>

<p>
    The goal of any good application framework or content system should be to make
    development of websites as easy as possible. Good systems make it possible to 
    use as little or as much of the framework as needed, and to make extension of 
    the framework trivial. This latter point is perhaps the most important aspect: 
    the quality of any good application ecosystem can typically be judged by the 
    amount and quality of third-party plugins developed for it. 
</p>

<p>
    If your framework is making you write boilerplate code to handle authentication
    for every site you write, or making you write code for common application 
    features such as blogs, comment systems, contact forms, etc., then something 
    is wrong. These sorts of tasks should be done at most a handful of times, and
    <em>shared</em> with the community.
</p>

<p>
    The end-goal is to be able to pull in a handful or more of plugins that do these
    tasks for you, configure them to suit your needs, and then focus on
    building out the functionality that is truly unique to your website.
</p>

<h2>Building Blocks</h2>

<p>
    I'll give a concrete example. In parallel with ZF2 development, I've been 
    rebuilding this very site. I've needed the following pieces:
</p>

<ul>
    <li>A handful of static pages (home page, r&eacute;sum&eacute;, etc.)</li>
    <li>A contact form</li>
    <li>A blog</li>
    <li>Authentication in order to "password protect" a few pages</li>
    <li>A few view helpers (github status, disqus display, etc)</li>
</ul>

<p>
    How much of this functionality is unique to my site, other than the content? Pretty
    much none of it. Ideally, I should be able to find some modules, drop them in, and 
    create some custom view scripts.
</p>

<p>
    Which is what I did. That said, I developed several of the modules, but in some cases,
    such as authentication, I was able to grab modules from elsewhere. The beauty, though,
    is that in the future, I or others can re-use what I've created, and quite easily.
</p>

<p>
    This kind of building-block development makes <em>your</em> job easier as a developer -- 
    and allows you to focus on the bits and pieces that make your site unique. As such, I 
    truly feel that <em><strong>modules are the most important new feature of ZF2</strong></em>.
</p>

<h2>Fin</h2>

<p>
    If you're developing on top of ZF2 today, I have one piece of advice: 
    create and consume modules. Share your modules.  Help make ZF2 a productive, 
    fun, collaborative ecosystem that allows developers to get
    things done and create fantastic new applications.
</p>]]></content:encoded>
      <slash:comments>0</slash:comments>
    </item>
    <item>
      <title>Developing A ZF2 Blog</title>
      <pubDate>Wed, 04 Apr 2012 02:50:00 +0000</pubDate>
      <link>http://mwop.net/blog/2012-05-developing-a-zf2-blog.html</link>
      <guid>http://mwop.net/blog/2012-05-developing-a-zf2-blog.html</guid>
      <author>me@mwop.net (Matthew Weier O'Phinney)</author>
      <dc:creator>Matthew Weier O'Phinney</dc:creator>
      <content:encoded><![CDATA[<p>
    This post tells a story.
</p>

<p>
    A long time ago, I set out to write my own blog platform. Yes, <a 
    href="http://wordpress.org">WordPress</a> is a fine blogging platform, as is 
    <a href="http://www.s9y.org/">Serendipity</a> (aka "s9y", and my previous 
    platform). And yes, I know about <a 
    href="http://habariproject.org">Habari</a>. And, for those of you skimming 
    ahead, yes, I'm quite aware of <a href="http://github.com/mojombo/jekyll">Jekyll</a>, 
    thank you anyways.
</p>

<p>
    Why write something of my own? Well, of course, there's the fact that I'm
    a developer, and have control issues. Then there's also the fact that a 
    blog is both a simple enough domain to allow easily experimenting with new
    technology and paradigms, while simultaneously providing a complex enough
    domain to expose non-trivial issues. 
</p>
    
<p>
    When I started this project, it was a technology-centered endeavor; I 
    wanted to play with document databases such as <a 
    href="http://couchdb.apache.org/">CouchDB</a> and <a 
    href="http://www.mongodb.org/">MongoDB</a>, and with caching technologies 
    like <a href="http://memcached.org">memcached</a> and <a 
    href="http://redis.io">redis</a>.
</p>

<p>
    Not long after I started, I also realized it was a great playground for me
    to prototype ideas for <a href="http://framework.zend.com/zf2">ZF2</a>;
    in fact, the original DI and MVC prototypes lived as branches of my blog.
    (My repository is still named "zf2sandbox" to this day, though it 
    technically houses just my site.)
</p>

<p>
    Over time, I had a few realizations. First, my <em>actual</em> blog was
    suffering. I wasn't taking the time to perform security updates, nor even
    normal upgrades, and was so far behind as to make the process non-trivial,
    particularly as I had a custom theme, and because I was proxying to my 
    blog via a ZF app in order to facilitate a cohesive site look-and-feel. I
    needed to either sink time into upgrading, or finish my blog.
</p>
    
<p>
    My second realization, however, was the more important one: I wanted a 
    platform where I could write how <em>I</em> want to write. I am
    a keyboard-centric developer and computer user, and while I love the web,
    I hate typing in its forms. Additionally, my posts often take longer than
    a typical browser session -- which leaves me either losing my work in a
    GUI admin, or having to write first in my editor of choice, and then 
    cut-and-paste it to the web forms. Finally, I want versions I can easily
    browse with standard diffing tools.
</p>

<p>
    When it came down to it, my blog content is basically static. Occasionally,
    I'll update a post, but it's rare. Comments are really the only dynamic
    aspect of the blog... and what I had with s9y was not cutting it, as I was
    getting more spam than I could keep up with. New commenting platforms such 
    as <a href="http://livefyre.com">Livefyre</a> and <a href="http://disqus.com">Disqus</a>
    provide more features than most blogging platforms I know, and provide 
    another side benefit: because they are javascript-based, you can simply
    drop in a small amount of markup into your post <em>once</em> -- meaning
    your pages can be fully static!
</p>

<p>
    Add these thoughts to the rise of static blogging platforms such as the 
    aforementioned Jekyll, and I had a kernel of an idea: take the work I'd
    done already, and create a static blog generator. 
</p><h2>Getting There</h2>

<p>
    This was not an overnight decision, nor an all-nighter project.
</p>

<p>
    The ground-work for my blog goes back a couple years, and originates with
    some of my presentations on domain models. The "kernel" of my blog today
    is the same as when I began a couple years ago, and is simply a domain
    entity class in plain old PHP that composes some values and behaviors.
    It composes an InputFilter, which allows it to validate itself. I 
    have <code class="hl">fromArray()</code> and <code class="hl">toArray()</code> methods to allow
    easy de/serialization for both PHP and JSON. In a nutshell, though, the
    following properties define my entries:
</p>

<div class="example"><pre><code lang="php">
class EntryEntity implements EntityDefinition
{
    protected $filter;

    protected $id;
    protected $title;
    protected $body = '';
    protected $extended = '';
    protected $author;
    protected $isDraft = true;
    protected $isPublic = true;
    protected $created;
    protected $updated;
    protected $timezone = 'America/New_York';
    protected $tags = array();
    protected $metadata = array();
    protected $comments = array();
    protected $version = 2;
}
</code></pre></div>

<p>
    The "id" is the "stub", the unique identifier for a given
    post, and is used in URLs. "isDraft" and "isPublic" are used to determine 
    whether or not a post is published on the site, and exposed in the various
    paginated views. The "created" and "updated" fields are timestamps, 
    resolved in relation to the "timezone". Tags are incorporated directly as a 
    PHP array.
</p>

<p>
    Some fields are legacy fields. The "version" was originally for me to 
    transition entries -- those in a version "1" would fold in "comments" 
    directly in the entry (as an array of Comment entities), while those in
    version "2" would use Disqus. Once I discovered that I could import
    old comments into Disqus, I no longer needed to incorporate comments
    at all, nor have separate versions. "metadata" was information that
    s9y stored about the post -- usually hints for rendering, or information 
    on categories (which became simply tags in my system). In future versions,
    I'll likely remove these fields.
</p>

<p>
    I eventually added an "Author" entity. I realized I would like primarily to 
    re-use this code in places where multiple authors might occur (such as the 
    <a href="http://framework.zend.com/zf2/blog">ZF2 blog</a>).
    Additionally, feeds need authorship information, and while I could provide
    defaults, it's even better to incorporate it directly into the posts.
    It is a simple value-object, composing only an identifier, name, email, and 
    URL for the author.
</p>

<p>
    With these building blocks, I was able to do any number of things. I wrote a 
    script to grab my s9y entries from the database, create entry
    entities, and then push them into first CouchDB, and later MongoDB.  I 
    exported comments to WXR, and imported them to Disqus. The architecture 
    proved more than flexible enough for me to do all this. I wrote a service
    layer on top of my code to provide easy ways to get paginated lists of
    recent entries, entries by year, entries by tag, and more. I wrote a
    small, custom mapper to persist the data, as well as retrieve it. I wrote my 
    MVC layer to be restful, which would allow me to write entities locally, 
    and then serialize them to JSON and PUT them to the server. A simple 
    API-key authentication layer ensured I'd not get inundated with bogus, 
    third-party posts.
</p>

<p>
    Life was good, and I re-launched my blog in December 2011, using MongoDB.
</p>

<h2>Refactoring</h2>

<p>
    I had a RESTful API, and it worked. But it still didn't feel right. I have
    a small VPS, and running both Apache and MongoDB was starting to tax it. I
    tried an experiment with caching, but quickly discovered that for the amounts
    of data I wanted to cache, I'd use almost the same I/O as if I just served
    the content from my framework.
</p>

<p>
    And that RESTful API? Well, it worked, but it never felt like a natural way
    to post entries, never mind updates.
</p>

<p>
    I revisited the idea of a static blog, almost by accident. I started 
    wondering if I could pre-compile my blog views to prime my cache. And once
    I started, I realized I could actually just generate the entire blog
    as static files. And it was fast! (I can generate several hundred posts in
    a matter of seconds.)
</p>

<p>
    I exported all my entries from MongoDB to plain old PHP files (for those keeping track: fourth
    persistence format: MySQL, CouchDB, MongoDB, filesystem) that defined
    and returned entry entity objects. I then started writing a compiler and
    code generator in three parts. The first part iterates recursively over a 
    directory, looking for PHP files (in fact, I had <a 
        href="http://mwop.net/blog/244-Applying-FilterIterator-to-Directory-Iteration.html">to 
        use my blog to remember how to do this</a>). The second part iterates
    over those files, grabbing the entries, and putting them into PriorityQueue
    objects, based on their timestamp; newer entries sort to the top. The
    third part is a collection of methods that iterate over the various queues,
    rendering paginated views, tag clouds, feeds, and entries, and writing the
    artifacts to disk. (This last part actually leverages and bastardizes the
    new ZF2 View layer introduced in beta3.)
</p>

<p>
    The result is a ZF2 module I called <a href="http://git.mwop.net/?a=summary&p=PhlyBlog">PhlyBlog</a>.
    It needs some refinement still, but it works; you can generate all the
    above artifacts, and more.
</p>

<p>
    The interesting part about code generation is that you can generate just
    about anything you want. I started out thinking I'd generate some view
    scripts that my controller would consume and inject into the layout. But
    I realized quickly that I could just as easily inject them into the layout
    during the generation process.
</p>

<p>
    And this is where I realized how happy I was with where ZF2 has gone. I 
    removed my "blog" module from my repository, exported it into a standalone 
    repository, and re-imported it to my site as a "third-party" vendor module. 
    Now, the mantra with ZF2 developers is that you should not alter vendor
    code. However, if you do things right, you should be able to <em>override</em>
    configuration and dependencies via <em>local configuration</em>. So I did 
    just that, to see if it would work.
</p>

<p>
    I first created callbacks to pass to my configuration -- one to handle the
    tag cloud, and store it in a variable so I could inject it into templates
    later; the other was to set my rendering strategy, as well as create a 
    "response" strategy that would inject the blog contents into a layout.
</p>

<div class="example"><pre><code lang="php">
namespace Application;

use Traversable;
use Zend\View\Model;

class Module
{
    // there's more; this is just the blog-specific stuff

    protected static $layout;
    public static function prepareCompilerView($view, $config, $locator)
    {
        // Setup the rendering strategy for the blog; use the PhpRenderer
        $renderer = $locator->get('Zend\View\Renderer\PhpRenderer');
        $view->addRenderingStrategy(function($e) use ($renderer) {
            return $renderer;
        }, 100);

        // Setup a layout view model
        self::$layout = $layout   = new Model\ViewModel();
        $layout->setTemplate('layout');

        // Add a "response" strategy; inject the rendered blog contents
        // into the layout. When done, reset artifacts such as the title,
        // shortcut icon, and javascript.
        $view->addResponseStrategy(function($e) use ($layout, $renderer) {
            $result = $e->getResult();
            $layout->setVariable('content', $result);
            $page   = $renderer->render($layout);
            $e->setResult($page);

            // Cleanup
            $headTitle = $renderer->plugin('headtitle');
            $headTitle->getContainer()->exchangeArray(array());
            $headTitle->append('phly, boy, phly');

            $headLink = $renderer->plugin('headLink');
            $headLink->getContainer()->exchangeArray(array());
            $headLink(array(
                'rel' => 'shortcut icon',
                'type' => 'image/vnd.microsoft.icon',
                'href' => '/images/Application/favicon.ico',
            ));

            $headScript = $renderer->plugin('headScript');
            $headScript->getContainer()->exchangeArray(array());
        }, 100);
    }

    public static function handleTagCloud($cloud, $view, $config, $locator)
    {
        // If we don't have a layout, don't do anything
        if (!self::$layout) {
            return;
        }

        // Add the rendered tag cloud to the footer
        self::$layout->setVariable('footer', sprintf(
            "&lt;h4>Tag Cloud&lt;/h4>\n&lt;div class=\"cloud\">\n%s&lt;/div>\n",
            $cloud->render()
        ));
    }
}
</code></pre></div>

<p>
    I then overrode the configuration locally -- again, not in the module, but
    at the application level configuration. Specifically, I setup custom
    paths for where to write my files, custom link specifications, defaults
    for titles and author, and configuration for the tag cloud. I did something
    else, too: I told it to use specific templates, not the ones in the 
    official module I'd created. Finally, I told it to use the callbacks
    above.
</p>

<p>
    And it just worked.
</p>

<p>
    I've moved all of my modules into separate projects at this time, and built
    my site from these building blocks. The site itself is very lean, and just
    consists of some basic wiring to setup template names and paths, configuration
    for services I use, specifications for assets. Deployment is basically
    pushing files to my repository, and running a simple script to update my
    site version and configuration; it's completely hands-off now, a goal
    I've wanted for literally years.
</p>

<p>
    And you know what? I'm enjoying tweaking my site and making it my own again
    for the first time in years.
</p>

<h2>My Blog Process</h2>

<p>
    Blogging for me now is done in the following steps:
</p>

<ul>
    <li>I go to my local working directory for my site.</li>
    <li>I create a new branch off my development branch: <code class="hl">git checkout -b post/blahblah develop</code></li>
    <li>I start editing a "post" file: <code class="hl">vim content/some-new-post.php</code></li>
    <li>It's a PHP file that creates an EntryEntity. I fill in some details, and start writing
        the content in plain old HTML. If I want, I can use Markdown or some other format,
        and use a PHP library to convert it to HTML.</li>
    <li>I commit the code, edit, commit again, lather, rinse, repeat until I like it.</li>
    <li>I merge it back to my development branch, and generate my blog. (I have a CLI tool for this: <code class="hl">./console 
        PhlyBlog:compile</code>)</li>
    <li>I preview it locally, as a sanity check.</li>
    <li>I merge it to my master branch, and deploy.</li>
</ul>

<p>
    Yes, it's less "simple" than going to an admin page in the browser and 
    typing. But it allows me to craft my entries exactly how I want. I can have
    many entries being drafted at any given time, without needing to worry about
    session timeouts or accidently hitting a "publish" button. I can write my
    posts in the editor I want, and eliminate copy-and-paste entirely from my
    workflow. I don't have to worry about traffic bringing down my database 
    and/or server. In short, it's a good fit <em>for me</em>.
</p>

<h2>An invitation</h2>

<p>
    If you're interested in this story, I'll be talking about it, and showing
    how to develop both modules and sites built on top of modules this June, 
    via a full-day tutorial at the <a href="http://phpconference.nl">Dutch PHP Conference</a>.
    Please join me, and a host of incredible speakers, in Amsterdam this summer!
</p>]]></content:encoded>
      <slash:comments>0</slash:comments>
    </item>
    <item>
      <title>View Layers, Database Abstraction, Configuration, Oh, My!</title>
      <pubDate>Mon, 05 Mar 2012 22:32:45 +0000</pubDate>
      <link>http://mwop.net/blog/zf2-beta3.html</link>
      <guid>http://mwop.net/blog/zf2-beta3.html</guid>
      <author>me@mwop.net (Matthew Weier O'Phinney)</author>
      <dc:creator>Matthew Weier O'Phinney</dc:creator>
      <content:encoded><![CDATA[<p>
    Late last week, the Zend Framework community <a href="http://framework.zend.com/zf2/blog/entry/Zend-Framework-2-0-0beta3-Released">2.0.0beta3</a>, 
    the latest iteration of the v2 framework. What have we been busy doing the 
    last couple months? In a nutshell, getting dirty with view layers, database
    abstraction, and configuration.
</p><h2>View Layers</h2>

<p>
    Working with and on Zend Framework as long as I have, one thing that has 
    always been a bit of a thorn in my side is how difficult it is to specify 
    differing view strategies based on arbitrary criteria. For instance, if 
    I want to return JSON, or XML, how can I do so? The "answer" in ZF1 is to
    use the ContextSwitch action helper, which basically simply overloads the
    filename suffix used for the view to include the format type -- 
    ".js.phtml", ".xml.phtml". This works, but it's a bit of a hack. (Full
    disclosure: I authored the hack.)
</p>

<p>
    Another problem I've always had is that rendering has occurred in multiple
    places of request execution. Action view scripts are rendered immediately
    following the action's execution, layouts are rendered at another time
    entirely. Using <code>Zend_View</code> as the renderer, this is fine, but
    if you want to switch to a solution that is capable of rendering the entire
    payload, including "child" views, at once, it becomes quite difficult to
    work around.
</p>

<p>
    For Zend Framework 2, I <a href="http://framework.zend.com/wiki/display/ZFDEV2/RFC+-+View+Layer">proposed a new view layer</a>,
    which helps mitigate some of these factors. As part of the work for this 
    proposal, I reorganized the component slightly to separate it into 
    "helpers", "renderers", and "resolvers" -- the latter are used to resolve a 
    template to a renderer-specific resource. Additionally, I introduced a new 
    concept into the framework, that of "View Models". This is a concept 
    borrowed from a number of different places, but most notably Microsoft, who 
    implemented them as part of a new pattern entitled "Model-View-ViewModel". 
    In this pattern, you bind data to a "ViewModel" object, which can contain 
    optional presentation logic, and pass the ViewModel to the View. The View 
    then grabs data from the ViewModel to present to the client.
</p>

<p>
    The biggest change, however, was introducing a "gateway" class, 
    <code>Zend\View\View</code>, with the responsibility of martialling a 
    renderer and injecting a response object. The code for this leverages the EventManager component to allow attaching "strategies" 
    for selecting a renderer. The selected renderer is then used to render the 
    template present in the ViewModel passed to the View object. Once 
    complete, we loop through response strategies, where the results of 
    rendering can be injected into the response. This also provides an ideal 
    location for adding headers, such as HTTP caching headers.
</p>

<p>
    Finally, I introduced a number of MVC listeners for view integration. Some of
    these are quite basic -- such as ensuring we have a listener that will trigger
    the view, and a default rendering strategy. Others help streamline the MVC -
    while we recommend returning ViewModel objects from your controllers, with
    templates set, default listeners provided will create ViewModels from returned
    associative arrays, and inject a template name based on the requested controller 
    and action.
</p>

<p>
    What do you really need to know from the outset? Not much!
</p>

<div class="example"><pre><code lang="php">
namespace Sample\Controller;

use Zend\Mvc\Controller\ActionController;

class HelloController extends ActionController
{
    public function worldAction()
    {
        // Implicitly creates a ViewModel with the below variables, and sets
        // the template to hello/world (:controller/:action)
        return array(
            'message' => 'Hello world!',
        );
    }
}
</code></pre></div>

<p>
    Basically, the most common use case is the one you'd expect to work. The
    fun really starts when you want to perform other common tasks: change the
    layout, disable the layout, specify an alternate template, add additional
    templates to render and aggregate in the layout, and more. In all cases,
    you work with ViewModels, and then let the renderer worry about how to
    represent them.
</p>

<p>
    For more details, <a href="http://packages.zendframework.com/docs/latest/manual/en/zend.view.html#zend.view.quick-start">read the Zend\View quickstart</a>.
</p>

<h2>Database Abstraction</h2>

<p>
    <code>Zend_Db</code> provides a ton of capabilities in Zend Framework v1. 
    However, over the years, we've discovered some design issues both in the 
    code itself as well as the tests which have made a number of features 
    difficult to support, and others difficult if not impossible to implement. 
    As <a href="http://ralphschindler.com/">Ralph</a> noted in his 
    <a href="http://framework.zend.com/wiki/display/ZFDEV2/RFC+-+Zend+Db">DB refactoring RFC</a>,
</p>

<blockquote>
    Each new feature request generally comes with it's own concerns that apply 
    to the project as a whole: "How useful is the feature?", "How does this 
    feature impact performance?", "How wide spread is the need for this 
    feature?". Generally, features are added to the core component bloating the 
    core component and adding a new set of code that has to be maintained.
</blockquote>

<p>
    The iteration for beta3 was to get the basic structure up and running for
    drivers and adapters (drivers are the low-level connections, adapters provide
    basic abstraction around common operations), resultset abstraction, the basic 
    infrastructure for SQL abstraction, metadata support, and a table/row data 
    gateway implementation.  All operations were tested on PDO_Sqlite, mysqli, 
    and sqlsrv; preliminary reports indicate most PDO drivers work out of the 
    box at this point.
</p>

<p>
    What does it look like?
</p>

<h4>Inserting data</h4>
<div class="example"><pre><code lang="php">
// where $adapter is an adapter object
$qi = function($name) use ($adapter) { 
    return $adapter->platform->quoteIdentifier($name); 
};
$fp = function($name) use ($adapter) { 
    return $adapter->driver->formatParameterName($name); 
};

$sql = 'INSERT INTO '
    . $qi('artist')
    . ' (' . $qi('name') . ', ' . $qi('history') . ') VALUES ('
    . $fp('name') . ', ' . $fp('history') . ')';

$statement = $adapter->query($sql);

$parameters = array(
    'name'    => 'New Artist',
    'history' => 'This is the history',
);

$statement->execute($parameters);
</code></pre></div>

<h4>Selecting data</h4>
<div class="example"><pre><code lang="php">
// where $adapter is an adapter object
$qi = function($name) use ($adapter) { 
    return $adapter->platform->quoteIdentifier($name); 
};
$fp = function($name) use ($adapter) { 
    return $adapter->driver->formatParameterName($name); 
};

$sql = 'SELECT * FROM ' . $qi('artist');
$statement = $adapter->query($sql);
$results = $statement->execute(array());

foreach ($results as $row) {
    var_export($row);
}
</code></pre></div>

<h4>TableGateway</h4>
<div class="example"><pre><code lang="php">
// where $adapter is an adapter object
$artistTable = new TableGateway('artist', $adapter);
$rowset = $artistTable->select(function (Select $select) {
    $select->where->like('name', 'Bar%');
});
$row = $rowset->current();
echo $row->name;
</code></pre></div>

<p>
    During my review of the code, which included assisting Ralph with testing,
    I was impressed with the heavy level of de-coupling present, and how easily
    it will allow us to support things like platform-specific SQL, custom 
    rowsets, and more.
</p>

<p>
    For more details, <a href="http://packages.zendframework.com/docs/latest/manual/en/zend.db.html">read the Zend\Db documentation</a>.
</p>

<h2>Configuration</h2>

<p>
    Configuration should be very fast. Interestingly, developers often also expect
    configuration to support a multitude of features -- key translation, 
    section inheritance, importing of additional configuration files, constant 
    substitution, compatibility with many configuration formats, and more. These 
    things tend to work in direct opposition to performance goals.
</p>

<p>
    Several ZF2 community members decided to tackle these issues. Their goal was 
    to create a streamlined core for <code>Zend\Config</code>, but provide a 
    variety of plugins and filters to provide the rich features many users
    have come to expect. The result is a very nice, de-coupled component.
</p>

<p>
    Basic usage remains the same as it always has. However, without enabling
    any optional features, you will not get things such as constant or token
    substitution; to get that, you can use the new Processor API:
</p>

<div class="example"><pre><code lang="php">
// Get our config object; second argument tells the factory to return
// a Config object, vs. an array
$config = Zend\Config\Factory::fromFile($pathToConfigFile, true);

// Process values, substituting constant values whenever a defined constant name 
// is encountered
$constants = new Zend\Config\Processor\Constant();
$constants->process($config);

// Define some tokens to substitute
$tokens = new Zend\Config\Processor\Token();
$tokens->addToken('TOKEN', 'bar');
$tokens->process($config);
</code></pre></div>

<p>
    This API makes performance-intensive features explicitly opt-in, leaving
    the core functionality intact and fast.
</p>

<p>
    For more details, <a href="http://packages.zendframework.com/docs/latest/manual/en/zend.config.html">read the Zend\Config documentation</a>.
</p>

<h2>Fin!</h2>

<p>
    I've only gone into depth on those features that had big iterations for the
    beta release; plenty more work went into it -- as I noted in the release 
    announcement, we handled around 200 pull requests over a 2 month period -- 
    this is roughly double what we accomplished for beta2 over a similar 
    timeframe! I'm quite impressed and humbled by the spirit of the ZF2 
    community and collaborators.
</p>

<p>
    If you haven't tried Zend Framework 2 yet, please give it a spin! While 
    there's still work to be done, for many -- most, potentially -- use cases,
    the functionality necessary is present and working very well. Trying it now,
    and building real functionality on it now, is not only possible, but will
    allow you to shape what ZF2 looks like when we're ready to go stable.
</p>

<p>
    <a href="http://packages.zendframework.com">Download it today!</a>
</p>]]></content:encoded>
      <slash:comments>0</slash:comments>
    </item>
    <item>
      <title>ZF2 Modules You Can Use Today</title>
      <pubDate>Wed, 08 Feb 2012 16:31:47 +0000</pubDate>
      <link>http://mwop.net/blog/zf2-modules-you-can-use-today.html</link>
      <guid>http://mwop.net/blog/zf2-modules-you-can-use-today.html</guid>
      <author>me@mwop.net (Matthew Weier O'Phinney)</author>
      <dc:creator>Matthew Weier O'Phinney</dc:creator>
      <content:encoded><![CDATA[<p>
    One key new architectural feature of Zend Framework 2 is its new module
    infrastructure. The basic idea behind modules is to allow developers to both
    create and consume re-usable application functionality -- anything from
    packaging common assets such as CSS and JavaScript to providing MVC
    application classes.
</p><p>
    As an example, for my own site, I've created: a "Contact" module for
    rendering and processing contact forms; a "SkeletonCSS" module for dropping
    in <a href="http://getskeleton.com">Skeleton</a> into my sites; a
    "CommonResource" module with a very, very basic data mapper implementation,
    and a "Blog" module that consumes it to deliver the very blog you're reading
    now.
</p>

<p>
    But the <em>real</em> goal of the module infrastructure is for developers to
    <em>share</em> their modules, so that other developers don't need to develop
    that very same functionality for their own site. And to my delight, that's
    already happening!
</p>

<p>
    So, here's a list of some of the ZF2 modules I've found in the wild.
</p>

<ul>
    <li><a href="http://bit.ly/yVBXkw">SkeletonCss</a>. I mentioned this one
        already, but it's a version of SkeletonCss, an adaptive response CSS/JS
        framework, packaged for easy consumption as a ZF2 module. The git URI is
        "git://mwop.net/SkeletonCss.git".</li>

    <li><a href="https://github.com/doctrine/DoctrineModule">DoctrineModule</a>.
        One of the most frequently asked questions I get is, "Will ZF2 use
        Doctrine?" My answer has been that we'll provide a bridge -- but the cool
        thing is that the Doctrine project has already decided to do it.
        Spear-headed by an enthusiastic ZF2 contributor/collaborator, <a
            href="http://twitter.com/SpiffyJr">Kyle Spraggs</a>, this module
        provides the base functionality for integrating Doctrine 2 into your ZF2
        site (primarily access to the base/common functionality). Two other
        modules provide additional functionality: <a
            href="https://github.com/doctrine/DoctrineORMModule">DoctrineORMModule</a>
        provides the ability to interact with the Doctrine 2 ORM, and <a
            href="https://github.com/doctrine/DoctrineMongoODMModule">DoctrineMongoODMModule</a>
        provides the ability to interact with and consume the Doctrine 2 Object
        Document Mapper for MongoDB.</li>

    <li><a href="https://github.com/EvanDotPro/EdpSuperluminal">EdpSuperluminal</a>.
        This module can be used to cache all classes you use in your application
        to a single include file -- giving you a performance boost.</li>

    <li><a href="https://github.com/ZF-Commons/ZfcUser">ZfcUser</a>. This module
        was begun by <a href="http://evan.pro">Evan Coury</a>, the lead
        developer behind ZF2's module system; its purpose is to provide a
        drop-in solution for registering and authenticating users. The module
        itself provides functionality consuming Zend\Db; however, several other
        modules are also offered to provide other persistence layers, including
        a <a href="https://github.com/ZF-Commons/ZfcUserDoctrineORM">ZfcUserDoctrineORM</a>
        module and a <a href="https://github.com/ZF-Commons/ZfcUserDoctrineORM">ZfcUserDoctrineMongoODM</a>
        module; more are planned. The "Zfc" namespace is used because Evan realized
        he and several others were working on similar solutions, and felt that
        collaboration would lead to a better solution than each would develop
        individually; this in turn led to the creation of a "Zend Framework
        Commons" organization on GitHub, with the goal of providing high-quality
        modules solving common application problems.</li>

    <li><a href="https://github.com/widmogrod/zf2-assetic-module">AsseticBundle</a>.
        This is a module providing integration with the excellent <a
            href="https://github.com/kriswallsmith/assetic">Assetic</a> asset
        management framework.</li>
            
    <li><a href="https://github.com/widmogrod/zf2-twitter-bootstrap-module">TwitterBootstrap</a>.
        Many developers are gravitating to the <a
            href="https://github.com/twitter/bootstrap">Twitter Bootstrap</a>
        project for CSS layouts. This module depends on the AsseticBundle
        already listed above, and provides both Twitter Bootstrap as well as
        integration with the current (ZF1) incarnation of Zend\Form.</li>
</ul>

<p>
    I've seen a number of others as well, and know of more on their way (as an
    example, a ZfcAcl module to complement the ZfcUser module). Writing modules
    is incredibly easy, and a great way to both learn ZF2 and collaborate and
    share with other developers.
</p>

<p>
    Where are <em>your</em> modules?
</p>]]></content:encoded>
      <slash:comments>0</slash:comments>
    </item>
    <item>
      <title>Why Conventions Matter</title>
      <pubDate>Thu, 12 Jan 2012 03:58:28 +0000</pubDate>
      <link>http://mwop.net/blog/why-conventions-matter.html</link>
      <guid>http://mwop.net/blog/why-conventions-matter.html</guid>
      <author>me@mwop.net (Matthew Weier O'Phinney)</author>
      <dc:creator>Matthew Weier O'Phinney</dc:creator>
      <content:encoded><![CDATA[<p>
    When I started teaching myself scripting languages, I started with Perl. One
    Perl motto is <a href="http://en.wikipedia.org/wiki/TMTOWTDI">"TMTOWTDI"</a>
    -- "There's More Than One Way To Do It," and pronounced "tim-toady." The
    idea is that there's likely multiple ways to accomplish the very same thing,
    and the culture of the language encourages finding novel ways to do things.
</p>

<p>
    I've seen this principle used everywhere and in just about every programming
    situation possible, applied to logical operations, naming conventions,
    formatting, and even project structure.  Everyone has an opinion on these
    topics, and given free rein to implement as they see fit, it's rare that two
    developers will come up with the same conventions.
</p>

<p>
    TMTOWTDI is an incredibly freeing and egalitarian principle.
</p>

<p>
    Over the years, however, my love for TMTOWTDI has diminished some.  Freeing
    as it is, is also a driving force behind having coding standards and
    conventions -- because when everyone does it their own way, projects become
    quickly hard to maintain. Each person finds themselves reformatting code to
    their own standards, simply so they can read it and follow its flow.
</p>

<p>
    Additionally, TMTOWTDI can actually be a foe of simple, elegant solutions.
</p>

<p>
    Why do I claim this?
</p><p>
    Recently, discussing module structure in Zend Framework 2, some folks were
    arguing that our recommended directory structure invokes the <a
        href="http://en.wikipedia.org/wiki/YAGNI">YAGNI</a> principle: You Ain't
    Gonna Need It.  Our recommendation is this:
</p>

<div class="example"><pre>
ModuleName/
    autoload_classmap.php
    Module.php
    config/
        module.config.php
        (other config files)
    public/
        css/
        images/
        js/
    src/
        ModuleName/
            (source files)
    test/
    view/
</pre></div>

<p>
    The argument is that since most modules implement a single namespace, and
    because we recommend following <a
        href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md">PSR-0</a>
    for autoloaders, it makes sense to simply have the source files directly
    under the module directory.
</p>

<div class="example"><pre>
ModuleName/
    autoload_classmap.php
    Module.php
    (other source files)
    config/
        module.config.php
        (other config files)
    public/
    test/
    view/
</pre></div>

<p>
    The argument myself and others made was that it makes sense to group the
    files by responsibility. However, the module system ultimately <em>doesn't
        care</em> how you organize the module -- we've embraced TMTOWTDI, and
    our only requirement is that for your module to be consumed, you must define
    a <code>ModuleName\Module</code> class, and notify the module manager how to
    find it. Anything goes.
</p>

<p>
    How does that bolster my argument about the importance of conventions? It
    doesn't. What does is what following the recommended structure enabled me to
    do.
</p>

<p>
    One common concern identified with having a re-usable module system is that
    you should be able to expose public assets easily: things like
    module-specific CSS or JavaScript, or even images. The first question that
    arises when you consider this is: where do I put them in my module? That's
    why the recommendation includes a <code>public</code> directory. In fact,
    the recommendation goes a step further, and suggests <code>css</code>,
    <code>images</code>, and <code>js</code> directories as well.
</p>

<p>
    Now, your modules are typically <em>outside</em> the document root. This is
    a rudimentary and fundamental security measure, and also simplifies
    deployment to a degree -- you don't need to worry about telling the web
    server about what it <em>shouldn't</em> serve. But if the modules are
    outside the document root, how can I expose their public assets?
</p>

<p>
    There are a two possibilities that immediately jump to mind:
</p>

<ul>
    <li>Install scripts for modules, which copy the files into the document root.</li>
    <li>Symlink the files into the document root.</li>
</ul>

<p>
    Both are valid, and easy to accomplish. Both raise the same question: where,
    exactly? What if multiple modules have public assets named the same? how do
    I refer to my assets withing things like view scripts?
</p>

<p>
    This is where having a convention starts to make sense: having a convention
    should answer these questions unambiguously.
</p>

<p>
    My answer: public access should be at
    <code>/css/ModuleName/stylesheetname</code>, or
    <code>/js/ModuleName/scriptname</code> or
    <code>/images/Modulename/imagename</code>. It's a dirt-simple rule that
    fulfills the use cases.
</p>

<p>
    However, I'm now stuck with having to develop either install scripts or
    remembering to create symlinks -- ugh. And that's where having conventions
    led me to a simple, elegant solution.
</p>

<p>
    I added one line to my Apache vhost definition:
</p>

<div class="example"><pre>
AliasMatch /(css|js|images)/([^/]+)/(.*) /path/to/module/$2/public/$1/$3
</pre></div>

<p>
    The translation:
</p>

<blockquote>
    When I come across a path to CSS, JS, or image files that are in a
    subdirectory, alias it to the corresponding public asset of the matched
    module directory.
</blockquote>

<p>
    I dropped this into my vhost, restarted Apache, and now not only were the
    assets I'd created already served, but any new ones I create are immediately
    available as well. Having a convention actually simplified my choices and my
    solutions.
</p>

<p>
    Rapid application development at its finest.
</p>

<p>
    My point is this: there will always be more than one way to do things when
    you're programming, and you may not always agree with the decisions your
    team has made, or the component library or framework you're using has made.
    However, if you poke around a little and play within those confines, you may
    find that those decisions make other decisions easier, or disappear
    altogether.
</p>]]></content:encoded>
      <slash:comments>0</slash:comments>
    </item>
    <item>
      <title>Getting started writing ZF2 modules</title>
      <pubDate>Sat, 12 Nov 2011 18:02:42 +0000</pubDate>
      <link>http://mwop.net/blog/267-Getting-started-writing-ZF2-modules.html</link>
      <guid>http://mwop.net/blog/267-Getting-started-writing-ZF2-modules.html</guid>
      <author>me@mwop.net (Matthew Weier O'Phinney)</author>
      <dc:creator>Matthew Weier O'Phinney</dc:creator>
      <content:encoded><![CDATA[<p>
During <a href="http://zendcon.com/">ZendCon</a> this year, we <a href="http://framework.zend.com/zf2/blog/entry/Zend-Framework-2-0-0beta1-Released">released 2.0.0beta1</a> of <a href="http://framework.zend.com">Zend Framework</a>.
The key story in the release is the creation of a new MVC layer, and to sweeten
the story, the addition of a modular application architecture.
</p>

<p>
"Modular? What's that mean?" For ZF2, "modular" means that your application is
built of one or more "modules". In a lexicon agreed upon during our IRC
meetings, a module is a collection of code and other files that solves a
specific atomic problem of the application or website. 
</p>

<p>
As an example, consider a typical corporate website in a technical arena. You
might have:
</p>

<ul>
<li>
A home page
</li>
<li>
Product and other marketing pages
</li>
<li>
Some forums
</li>
<li>
A corporate blog
</li>
<li>
A knowledge base/FAQ area
</li>
<li>
Contact forms
</li>
</ul>

<p>
These can be divided into discrete modules:
</p>

<ul>
<li>
A "pages" modules for the home page, product, and marketing pages
</li>
<li>
A "forum" module
</li>
<li>
A "blog" module
</li>
<li>
An "faq" or "kb" module
</li>
<li>
A "contact" module
</li>
</ul>

<p>
Furthermore, if these are developed well and discretely, they can be <em>re-used</em>
between different applications!
</p>

<p>
So, let's dive into ZF2 modules!
</p><h2 id="toc_1.2">What is a module?</h2>

<p>
In ZF2, a module is simply a namespaced directory, with a single "Module" class
under it; no more, and no less, is required.
</p>

<p>
So, as an example:
</p>

<pre>
modules/
    FooBlog/
        Module.php
    FooPages/
        Module.php
</pre>

<p>
The above shows two modules, "FooBlog" and "FooPages". The "Module.php" file
under each contains a single "Module" class, namespaced per the module:
<code>FooBlog\Module</code> and <code>FooPages\Module</code>, respectively.
</p>

<p>
This is the one and only requirement of modules; you can structure them however
you want from here. However, we <em>do</em> have a <em>recommended</em> directory structure:
</p>

<pre>
modules/
    SpinDoctor/
        Module.php
        configs/
            module.config.php
        public/
            images/
            css/
                spin-doctor.css
            js/
                spin-doctor.js
        src/
            SpinDoctor/
                Controller/
                    SpinDoctorController.php
                    DiscJockeyController.php
                Form/
                    Request.php
        tests/
            bootstrap.php
            phpunit.xml
            SpinDoctor/
                Controller/
                    SpinDoctorControllerTest.php
                    DiscJockeyControllerTest.php
</pre>

<p>
The important bits from above:
</p>

<ul>
<li>
Configuration goes in a "configs" directory.
</li>
<li>
Public assets, such as javascript, CSS, and images, go in a "public"
   directory.
</li>
<li>
PHP source code goes in a "src" directory; code under that directory should
   follow <a href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md">PSR-0 standard structure</a>.
</li>
<li>
Unit tests should go in a "tests" directory, which should also contain your
   PHPUnit configuration and bootstrapping.
</li>
</ul>

<p>
Again, the above is simply a <em>recommendation</em>. Modules in that structure clearly
dileneate the purpose of each subtree, allowing developers to easily introspect
them.
</p>

<h2 id="toc_1.3">The Module class</h2>

<p>
Now that we've discussed the minimum requirements for creating a module and its
structure, let's discuss the minimum requirement: the Module class.
</p>

<p>
The module class, as noted previously, should exist in the module's namespace.
Usually this will be equivalent to the module's directory name. Beyond that,
however, there are no real requirements, other than the constructor should not
require any arguments.
</p>

<div class="example"><pre><code lang="php">
namespace FooBlog;

class Module
{
}
</code></pre></div>

<p>
So, what do module classes do, then? 
</p>

<p>
The module manager (class <code>Zend\Module\Manager</code>) fulfills three key purposes:
</p>

<ul>
<li>
It aggregates the enabled modules (allowing you to loop over the classes
   manually).
</li>
<li>
It aggregates configuration from each module.
</li>
<li>
It triggers module initialization, if any.
</li>
</ul>

<p>
I'm going to skip the first item and move directly to the configuration aspect.
</p>

<p>
Most applications require some sort of configuration. In an MVC application,
this may include routing information, and likely some dependency injection
configuration. In both cases, you likely don't want to configure anything until
you have the full configuration available -- which means all modules must be
loaded.
</p>

<p>
The module manager does this for you. It loops over all modules it knows about,
and then merges their configuration into a single configuration object. To do
this, it checks each Module class for a <code>getConfig()</code> method.
</p>

<p>
The <code>getConfig()</code> method simply needs to return an <code>array</code> or <code>Traversable</code>
object. This data structure should have "environments" at the top level -- the
"production", "staging", "testing", and "development" keys that you're used to
with ZF1 and <code>Zend_Config</code>. Once returned, the module manager merges it with its
master configuration so you can grab it again later.
</p>

<p>
Typically, you should provide the following in your configuration:
</p>

<ul>
<li>
Dependency Injection configuration
</li>
<li>
Routing configuration
</li>
<li>
If you have module-specific configuration that falls outside those, the
   module-specific configuration. We recommend namespacing these keys after the
   module name: <code>foo_blog.apikey = "..."</code>
</li>
</ul>

<p>
The easiest way to provide configuration? Define it as an array, and return it
from a PHP file -- usually your <code>configs/module.config.php</code> file. Then your
<code>getConfig()</code> method can be quite simple:
</p>

<div class="example"><pre><code lang="php">
public function getConfig()
{
    return include __DIR__ . '/configs/module.config.php';
}
</code></pre></div>

<p>
In the original bullet points covering the purpose of the module manager, the
third bullet point was about module initialization. Quite often you may need to
provide additional initialization once the full configuration is known and the
application is bootstrapped -- meaning the router and locator are primed and
ready. Some examples of things you might do:
</p>

<ul>
<li>
Setup event listeners. Often, these require configured objects, and thus need
   access to the locator.
</li>
<li>
Configure plugins. Often, you may need to inject plugins with objects managed
   by the locator. As an example, the <code>url()</code> view helper needs a configured
   router in order to work.
</li>
</ul>

<p>
The way to do these tasks is to subscribe to the bootstrap object's "bootstrap"
event:
</p>

<div class="example"><pre><code lang="php">
$events = StaticEventManager::getInstance();
$events-&gt;attach('bootstrap', 'bootstrap', array($this, 'doMoarInit'));
</code></pre></div>

<p>
That event gets the application and module manager objects as parameters, which
gives you access to everything you might possibly need.
</p>

<p>
The question is: where do I do this? The answer: the module manager will call a
Module class's <code>init()</code> method if found. So, with that in hand, you'll have the
following:
</p>

<div class="example"><pre><code lang="php">
namespace FooBlog;

use Zend\EventManager\StaticEventManager,
    Zend\Module\Manager as ModuleManager

class Module
{
    public function init(ModuleManager $manager)
    {
        $events = StaticEventManager::getInstance();
        $events-&gt;attach('bootstrap', 'bootstrap', array($this, 'doMoarInit'));
    }
    
    public function doMoarInit($e)
    {
        $application = $e-&gt;getParam('application');
        $modules     = $e-&gt;getParam('modules');
        
        $locator = $application-&gt;getLocator();
        $router  = $application-&gt;getRouter();
        $config  = $modules-&gt;getMergedConfig();
        
        // do something with the above!
    }
}
</code></pre></div>

<p>
As you can see, when the bootstrap event is triggered, you have access to the
<code>Zend\Mvc\Application</code> instance as well as the <code>Zend\Module\Manager</code> instance,
giving you access to your configured locator and router, as well as merged
configuration from all modules! Basically, you have everything you could
possibly want to access right at your fingertips.
</p>

<p>
What else might you want to do during <code>init()</code>? One very, very important thing:
setup autoloading for the PHP classes in your module!
</p>

<p>
ZF2 offers several different autoloaders to provide different strategies geared
towards ease of development to production speed. For beta1, they were refactored
slightly to make them even more useful. The primary change was to the
<code>AutoloaderFactory</code>, to allow it to keep single instances of each autoloader it
handles, and thus allow specifying additional configuration for each. As such,
this means that if you use the <code>AutoloaderFactory</code>, you'll only ever have one
instance of a <code>ClassMapAutoloader</code> or <code>StandardAutoloader</code> -- and this means
each module can simply add to their configuration.
</p>

<p>
As such, here's a typical autoloading boilerplate:
</p>

<div class="example"><pre><code lang="php">
namespace FooBlog;

use Zend\EventManager\StaticEventManager,
    Zend\Loader\AutoloaderFactory,
    Zend\Module\Manager as ModuleManager

class Module
{
    public function init(ModuleManager $manager)
    {
        $this-&gt;initializeAutoloader();
        // ...
    }
    
    public function initializeAutoloader()
    {
        AutoloaderFactory::factory(array(
            'Zend\Loader\ClassMapAutoloader' =&gt; array(
                include __DIR__ .  '/autoload_classmap.php',
            ),
            'Zend\Loader\StandardAutoloader' =&gt; array(
                'namespaces' =&gt; array(
                    __NAMESPACE__ =&gt; __DIR__ . '/src/' .  __NAMESPACE__,
                ),
            ),
        ));
    }
</code></pre></div>
    
<p>
During development, you can have <code>autoload_classmap.php</code> return an empty array,
but then during production, you can generate it based on the classes in your
module. By having the <code>StandardAutoloader</code> in place, you have a backup solution
until the classmap is updated.
</p>

<p>
Now that you know how your module can provide configuration, and how it can tie
into bootstrapping, I can finally cover the original point: the module manager
aggregates enabled modules. This allows modules to "opt-in" to additional
features of an application. As an example, you could make modules "ACL aware",
and have a "security" module grab module-specific ACLs:
</p>

<div class="example"><pre><code lang="php">
    public function initializeAcls($e)
    {
        $this-&gt;acl = new Acl;
        $modules   = $e-&gt;getParam('modules');
        foreach ($modules-&gt;getLoadedModules() as $module) {
            if (!method_exists($module, 'getAcl')) {
                continue;
            }
            $this-&gt;processModuleAcl($module-&gt;getAcl());
        }
    }
</code></pre></div>

<p>
This is an immensely powerful technique, and I'm sure we'll see a lot of
creative uses for it in the future!
</p>

<h2 id="toc_1.4">Composing modules into your application</h2>

<p>
So, writing modules should be easy, right? Right?!?!?
</p>

<p>
The other trick, then, is telling the module manager about your modules. There's
a reason I've used phrases like, "enabled modules" "modules it [the module
manager] knows about," and such: the module manager is opt-in. You have to
<em>tell</em> it what modules it will load.
</p>

<p>
Some may say, "Why? Isn't that against rapid application development?" Well, yes
and no. Consider this: what if you discover a security issue in a module? You
could remove it entirely from the repository, sure. Or you could simply update
the module manager configuration so it doesn't load it, and then start testing
and patching it in place; when done, all you need to do is re-enable it.
</p>

<p>
Loading modules is a two-stage process. First, the system needs to know where
and how to locate module classes. Second, it needs to actually load them. We
have two components surrounding this:
</p>

<ul>
<li>
<code>Zend\Loader\ModuleAutoloader</code>
</li>
<li>
<code>Zend\Module\Manager</code>
</li>
</ul>

<p>
The <code>ModuleAutoloader</code> takes a list of paths, or associations of module names to
paths, and uses that information to resolve <code>Module</code> classes. Often, modules
will live under a single directory, and configuration is as simple as this:
</p>

<div class="example"><pre><code lang="php">
$loader = new Zend\Loader\ModuleAutoloader(array(
    __DIR__ . '/../modules',
));
$loader-&gt;register();
</code></pre></div>

<p>
You can specify multiple paths, or explicit module:directory pairs:
</p>

<div class="example"><pre><code lang="php">
$loader = new Zend\Loader\ModuleAutoloader(array(
    __DIR__ . '/../vendors',
    __DIR__ . '/../modules',
    'User' =&gt; __DIR__ . '/../vendors/EdpUser-0.1.0',
));
$loader-&gt;register();
</code></pre></div>

<p>
In the above, the last will look for a <code>User\Module</code> class in the file
<code>vendors/EdpUser-0.1.0/Module.php</code>, but expect that modules found in the other
two directories specified will always have a 1:1 correlation between the
directory name and module namespace.
</p>

<p>
Once you have your <code>ModuleAutoloader</code> in place, you can invoke the module
manager, and inform it of what modules it should load. Let's say that we have
the following modules:
</p>

<pre>
modules/
    Application/
        Module.php
    Security/
        Module.php
vendors/
    FooBlog/
        Module.php
    SpinDoctor/
        Module.php
</pre>

<p>
and we wanted to load the "Application", "Security", and "FooBlog" modules.
Let's also assume we've configured the <code>ModuleAutoloader</code> correctly already. We
can then do this:
</p>

<div class="example"><pre><code lang="php">
$manager = new Zend\Module\Manager(array(
    'Application',
    'Security',
    'FooBlog',
));
$manager-&gt;loadModules();
</code></pre></div>

<p>
We're done! If you were to do some profiling and introspection at this point,
you'd see that the "SpinDoctor" module will not be represented -- only those
modules we've configured. 
</p>

<p>
To make the story easy and reduce boilerplate, the <a href="https://github.com/zendframework/ZendSkeletonApplication">ZendSkeletonApplication</a> repository provides a basic bootstrap for you in <code>public/index.php</code>. This file consumes <code>configs/application.config.php</code>, in which you specify two keys, "module_paths" and "modules":
</p>

<div class="example"><pre><code lang="php">
return array(
    'module_paths' =&gt; array(
        realpath(__DIR__ . '/../modules'),
        realpath(__DIR__ . '/../vendors'),
    ),
    'modules' =&gt; array(
        'Application',
        'Security',
        'FooBlog',
    ),
);
</code></pre></div>

<p>
It doesn't get much simpler at this point.
</p>

<h2 id="toc_1.5">Tips and Tricks</h2>

<p>
One trick I've learned deals with how and when modules are loaded. In the
previous section, I introduced the module manager and how it's notified of what
modules we're composing in this application. One interesting thing is that
modules are processed in the order in which they are provided in your
configuration. This means that the configuration is merged in that order as
well.
</p>

<p>
The trick then, is this: if you want to override configuration settings, don't
do it in the modules; create a special module that loads last to do it!
</p>

<p>
So, consider this module class:
</p>

<div class="example"><pre><code lang="php">
namespace Local;

class Module
{
    public function getConfig()
    {
        return include __DIR__ . '/configs/module.config.php';
    }
}
</code></pre></div>

<p>
We then create a configuration file in <code>configs/module.config.php</code>, and specify
any configuration overrides we want there!
</p>

<div class="example"><pre><code lang="php">
return array(
    'production' =&gt; array(
        'di' =&gt; 'alias' =&gt; array(
            'view' =&gt; 'My\Custom\Renderer',
        ),
    ),
);
</code></pre></div>

<p>
Then, in our <code>configs/application.config.php</code>, we simply enable this module as
the last in our list:
</p>

<div class="example"><pre><code lang="php">
return array(
    // ...
    'modules' =&gt; array(
        'Application',
        'Security',
        'FooBlog',
        'Local',
    ),
);
</code></pre></div>

<p>
Done!
</p>

<h2 id="toc_1.6">Fin</h2>

<p>
Modules in ZF2 are incredibly flexible and powerful. I didn't even cover some of
the features -- such as the ability to use phar files (or any format phar
supports) as modules, or the ability to cache module configuration, etc.
Hopefully, however, I've outlined their simplicity for you, so you can start
harnessing their power for yourself!
</p>

<h3 id="toc_1.6.1">Disclaimer</h3>

<p>
ZF2 is in beta stage at this time, and Zend Framework is not guaranteeing BC
between beta releases. If you choose to test or build on ZF2, be aware that you
may need to make changes between releases. That said, please <em>do</em> test, and
provide your feedback!
</p>

<h3 id="toc_1.6.2">Updates</h3>
<ul>
    <li><b>2011-11-07 14:30 CST</b>: Updated config FooBlog.apikey to read foo_blog.apikey, per ZF2 config naming standards</li>
</ul>]]></content:encoded>
      <slash:comments>0</slash:comments>
    </item>
  </channel>
</rss>
