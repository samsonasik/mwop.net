<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title type="text">Blog Entries :: phly, boy, phly</title>
  <updated>2012-12-30T15:52:00+0000</updated>
  <generator uri="http://framework.zend.com" version="2.0.5">Zend_Feed_Writer</generator>
  <link rel="alternate" type="text/html" href="http://mwop.net/blog.html"/>
  <link rel="self" type="application/atom+xml" href="http://mwop.net/blog-atom.xml"/>
  <id>http://mwop.net/blog.html</id>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[OpenShift, Cron, and Naked Domains]]></title>
    <published>2012-12-30T15:52:00+0000</published>
    <updated>2012-12-30T15:52:00+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/2012-12-30-openshift-cron-and-naked-domains.html"/>
    <id>http://mwop.net/blog/2012-12-30-openshift-cron-and-naked-domains.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>As an experiment, I migrated my website over to <xhtml:a href="http://openshift.redhat.com">OpenShift</xhtml:a> yesterday. I've been
hosting a pastebin there already, and have found the service to be
both straightforward and flexible; it was time to put it to a more
thorough test.</xhtml:p>
<xhtml:p>In the process, I ran into a number of interesting issues, some
of which took quite some time to resolve; this post is both to help
inform other potential users of the service, as well as act as a
reminder to myself.</xhtml:p>
<xhtml:h2>Cron</xhtml:h2>
<xhtml:p>OpenShift offers a <xhtml:a href="http://en.wikipedia.org/wiki/Cron">Cron</xhtml:a> cartridge, which I was
excited to try out.<xhtml:sup><xhtml:a href="#f1">1</xhtml:a></xhtml:sup></xhtml:p>
<xhtml:p>The basics are quite easy. In your repository's
<xhtml:code>.openshift</xhtml:code> directory is a <xhtml:code>cron</xhtml:code>
subdirectory, further divided into <xhtml:code>minutely</xhtml:code>,
<xhtml:code>hourly</xhtml:code>, <xhtml:code>daily</xhtml:code>, <xhtml:code>weekly</xhtml:code>, and
<xhtml:code>monthly</xhtml:code> subdirectories. You drop a script you want to
run into one of these directories, and push your changes
upstream.</xhtml:p>
<xhtml:p>The problem is: what if I want a job to run at a specific time
daily? or on the quarter hour? or on a specific day of the
week?</xhtml:p>
<xhtml:p>As it turns out, you can manage all of the above, just not quite
as succinctly as you would in a normal crontab. Here, for example,
is a script that I run at 5AM daily; I placed it in the
<xhtml:code>hourly</xhtml:code> directory so that it can test more
frequently:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="bash">
#!/bin/bash
if [ `date +%H` == "05" ]
then
    (
        export PHP=/usr/local/zend/bin/php ;
        cd $OPENSHIFT_REPO_DIR ; 
        $PHP public/index.php phlycomic fetch all ; 
        $PHP public/index.php phlysimplepage cache clear --page=pages/comics 
    )
fi
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>And here's one that runs on the quarter-hour, placed in the
<xhtml:code>minutely</xhtml:code> directory:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="bash">
#!/bin/bash
MINUTES=`date +%M`

for i in "00" "15" "30" "45";do
    if [ "$MINUTES" == "$i" ];then
        (
            export PHP=/usr/local/zend/bin/php ;
            cd $OPENSHIFT_REPO_DIR ;
            $PHP public/index.php githubfeed fetch 
        )
    fi
done
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>The point is that if you need more specificity, push the script
into the next more specific directory, and test against the time of
execution.</xhtml:p>
<xhtml:h2>Naked Domains</xhtml:h2>
<xhtml:p>Naked domains are domains without a preceding subdomain. In my
case, this means "mwop.net", vs. "www.mwop.net".</xhtml:p>
<xhtml:p>The problem that cloud hosting presents is that the IP address
on which you are hosted can change at any time, for a variety of
reasons. As such, you typically cannot use DNS A records to point
to your domain; the recommendation is to use a CNAME record that
points the domain to a "virtual" domain registered with your cloud
hosting provider.</xhtml:p>
<xhtml:p>However, most domain registrars and DNS providers do not let you
do this for a naked domain, particularly if you also have MX or
other records associated with that naked domain.</xhtml:p>
<xhtml:p>Some registrars will allow you to forward the A record to a
subdomain. I tried this, but had limited success; I personally
found that I ended up in an infinite loop situation when doing the
DNS lookup.</xhtml:p>
<xhtml:p>Another solution is to have a redirect in place for your naked
domain to the subdomain, which can then be a CNAME record.
Typically, this would require you have a web server under your
control with a fixed IP that then simply redirects to the
subdomain. Fortunately, there's an easier solution: <xhtml:a href="http://wwwizer.com/naked-domain-redirect">wwwizer</xhtml:a>. You simply
point your naked domain A record to the wwwizer IP address, and
they will do a redirect to your <xhtml:code>www</xhtml:code> subdomain.</xhtml:p>
<xhtml:p>I implemented wwwizer on my domain (which is why you'll see
"www.mwop.net" in your location bar), and it's been working
flawlessly since doing so.</xhtml:p>
<xhtml:h4>Private repositories</xhtml:h4>
<xhtml:p>I keep my critical site settings in a private repository, which
allows me to version them while keeping the credentials they hold
out of the public eye. This means, however, that I need to use
<xhtml:a href="https://help.github.com/articles/managing-deploy-keys">GitHub
deploy keys</xhtml:a> on my server in order to retrieve changes.</xhtml:p>
<xhtml:p>This was simple enough: I created an <xhtml:code>ssh</xhtml:code>
subdirectory in my <xhtml:code>$OPENSHIFT_DATA_DIR</xhtml:code> directory, and
generated a new SSH keypair.</xhtml:p>
<xhtml:p>The problem was telling SSH to <xhtml:em>use</xhtml:em> this key when
fetching changes.</xhtml:p>
<xhtml:p>The solution is to use a combination of <xhtml:code>ssh-agent</xhtml:code>
and <xhtml:code>ssh-add</xhtml:code>, and it looks something like this:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="bash">
#!/bin/bash
ssh-agent `ssh-add $OPENSHIFT_DATA_DIR/ssh/github-key &amp;&amp; (
    cd $OPENSHIFT_DATA_DIR/config ; 
    git fetch origin ; 
    git rebase origin/mwop.net.config
)`
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>After testing the above, I put this in a <xhtml:code>pre_build</xhtml:code>
script in my OpenShift configuration so that I can autoupdate my
private configuration on each build. However, I discovered a new
problem: when a build is being done, the <xhtml:code>ssh-agent</xhtml:code> is
not available, which means the above cannot be executed. I'm still
trying to find a solution.</xhtml:p>
<xhtml:h2>Fin</xhtml:h2>
<xhtml:p>I'm pretty happy with the move. I don't have to do anything
special to automate deployment, and all my cronjobs and deployment
scripts are now self-contained in the repository, which makes my
site more portable. While a few things could use more
documentation, all the pieces are there and discoverable with a
small amount of work.</xhtml:p>
<xhtml:p>I'll likely give some other PaaS providers a try in the future,
but for the moment, I'm quite happy with the functionality and
flexibility of OpenShift.</xhtml:p>
<xhtml:h4>Footnotes</xhtml:h4>
<xhtml:ul>
<xhtml:li id="f1">Zend Server's JobQueue can also be used as a cron
replacement, but I was not keen on exposing the job functionality
via HTTP.</xhtml:li>
</xhtml:ul>
</xhtml:div>
    </content>
  </entry>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[On php-fig and Shared Interfaces]]></title>
    <published>2012-12-20T20:23:00+0000</published>
    <updated>2012-12-20T20:23:00+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/2012-12-20-on-shared-interfaces.html"/>
    <id>http://mwop.net/blog/2012-12-20-on-shared-interfaces.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>This is a post I've been meaning to write for a long time, and
one requested of me personally by <xhtml:a href="http://www.rooftopsolutions.nl/blog/">Evert Pot</xhtml:a> during the
Dutch PHP Conference in June 2012. It details some observations I
have of php-fig, and hopefully will serve as a record of why I'm
not directly participating any longer.</xhtml:p>
<xhtml:p>I was a founding member of the <xhtml:a href="http://www.php-fig.org/">Framework Interoperability Group</xhtml:a>, now
called "php-fig". I was one of around a dozen folks who sat around
a table in 2009 in Chicago during php|tek and started discussions
about what we could all do to make it possible to work better
together between our projects, and make it simpler for users to
pick and choose from our projects in order to build the solutions
to their own problems.</xhtml:p>
<xhtml:p>The first "standard" that came from this was <xhtml:a href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md">
PSR-0</xhtml:a>, which promoted a standard class naming convention that
uses a 1:1 relationship between the namespace and/or vendor prefix
and the directory hierarchy, and the class name and the filename in
which it lives. To this day, there are both those who hail this as
a great step forward for cooperation, and simultaneously others who
feel it's a terrible practice.</xhtml:p>
<xhtml:p>And then nothing, for years. But a little over a year ago, there
was a new push by a number of folks wanting to do more. Paul Jones
did a remarkable job of spearheading the next <xhtml:a href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-1-basic-coding-standard.md">
two</xhtml:a> <xhtml:a href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md">
standards</xhtml:a>, which centered around coding style. Again, just like
with PSR-0, we had both those feeling it was a huge step forward,
and those who loathe the direction.</xhtml:p>
<xhtml:p>What was interesting, though, was that once we started seeing
some new energy and momentum, it seemed that <xhtml:em>everyone</xhtml:em>
wanted a say. And we started getting dozens of folks a week asking
to be voting members, and new proposal after new proposal. Whether
or not somebody likes an existing standard, they want to have
backing for a standard they propose.</xhtml:p>
<xhtml:p>And this is when we started seeing proposals surface for shared
interfaces, first around caching, and now around logging (though
the latter is the first up for vote).</xhtml:p>
<xhtml:h2>Shared Interfaces</xhtml:h2>
<xhtml:p>The idea around shared interfaces is simple: if we can come to a
consensus on the basic interface for a common application task,
libraries and frameworks can typehint on that shared interface,
allowing developers to drop in the implementation of their choosing
-- or even a standard, reference implementation. The goal is to
prevent Not Invented Here (NIH) syndrome, as well as to make it
simpler to re-use components between one library and another. As an
example, if you're using Framework A, and it has a caching library,
and you're consuming ORM B, you'd be able to pass the same cache
object to the ORM as you use in the framework.</xhtml:p>
<xhtml:p>Great goals, really.</xhtml:p>
<xhtml:p>But I'm not sure I buy into them.</xhtml:p>
<xhtml:h2>Problems</xhtml:h2>
<xhtml:p>First, I agree that NIH is a problem.</xhtml:p>
<xhtml:p>Second, I <xhtml:em>also</xhtml:em> think there's space for <xhtml:em>multiple
implementations</xhtml:em> of any given component. Often there are
different approaches that different authors will take: one might
focus on performance, another on having multiple adapters for
providing different capabilities, etc. Sometimes having a different
background will present different problem areas you want to
resolve. As such, having multiple implementations can be a very
good thing; developers can look at what each provides, and
determine which solves the particular issues presented in the
current project.</xhtml:p>
<xhtml:p>Because of this latter point, I have my reservations about
shared interfaces.</xhtml:p>
<xhtml:p>What if a particular approach requires deviating from the shared
interface in order to accomplish its goals? Additionally, in order
to keep the greatest amount of compatibility between projects,
shared interfaces tend to be so generic that specific
implementations require developers to do a ton of manual type
checking and munging of parameters, leading to more overhead, more
difficulty testing and maintaining, and more difficulty documenting
and understanding.</xhtml:p>
<xhtml:p>As an example, consider the following (made up) signature for a
log method:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
public function log($message, array $context = null);
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>What if your library supports an idea of priorities? Where would
that information go in the above signature -- and would that differ
between libraries -- would one library use the key for a completely
different purpose? What about logging objects -- the signature
doesn't say you can't, but how would I know if a specific
implementation supports it, and won't blow up if I do pass one? Why
must the <xhtml:code>$context</xhtml:code> be an array -- why won't any
<xhtml:code>Traversable</xhtml:code> or <xhtml:code>ArrayAccess</xhtml:code> object
work?</xhtml:p>
<xhtml:p>Basically, by being overly generic, the signature becomes a
liability for those implementing the interface; it prevents
meaningful interoperability and leads to splintering
implementations.</xhtml:p>
<xhtml:p><xhtml:em>(Please note: the above is completely fictional and has no
bearing on current proposed or accepted standards. It is a thought
exercise only.)</xhtml:em></xhtml:p>
<xhtml:p>Furthermore, if a given project writes their own implementation
of a component, and it has specialized features, why would they
want to typehint on a generic, shared interface that doesn't
implement those features? This would be counter-intuitive, as the
project would then need to either check on additional interfaces
for the specialized capabilities, duck-type, etc. -- all of which
make for more maintenance and code.</xhtml:p>
<xhtml:p>In summary, my primary problem with the idea of shared
interfaces is that I feel there is always room for new thinking and
ideas in any given problem space, and that this thinking should not
be restricted by what already exists. Secondarily, I feel that it's
okay for a given project to be selective about what capabilities it
requires for its internal consumption and consistency, and should
not limit itself to a standardized interface.</xhtml:p>
<xhtml:h2>But, but, SHARING</xhtml:h2>
<xhtml:p><xhtml:em>Remember, the first point I made was that I think NIH is a
problem.</xhtml:em> How do I reconcile that with a firm stance against
shared interfaces?</xhtml:p>
<xhtml:p>Easy: <xhtml:a href="http://en.wikipedia.org/wiki/Bridge_pattern">bridges</xhtml:a> and/or
<xhtml:a href="http://en.wikipedia.org/wiki/Adapter_pattern">adapters</xhtml:a>.</xhtml:p>
<xhtml:p>Let's go back to that example of Framework A, its caching
library, and working with ORM B.</xhtml:p>
<xhtml:p>Let's assume that ORM B defines an interface for caching, and
let's say it looks like this:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
interface CacheInterface
{
    public function set($key, $data);
    public function has($key);
    public function get($key);
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Furthermore, we'll assume that the expected parameter values and
return types are documented.</xhtml:p>
<xhtml:p>What we as a consumer of both Framework A and ORM B can do is
build an <xhtml:em>implementation</xhtml:em> of <xhtml:code>CacheInterface</xhtml:code>
that accepts a cache instance from Framework A, and proxies the
various interface methods to that instance.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
class FrameworkACache implements CacheInterface
{
    protected $cache;

    public function __construct(Cache $cache)
    {
        $this-&gt;cache = $cache;
    }

    public function set($key, $data)
    {
        $item = new CacheItem($key, $data);
        $this-&gt;cache-&gt;setItem($item);
    }

    public function has($key)
    {
        return $this-&gt;cache-&gt;exists($key);
    }

    public function get($key)
    {
        $item = $this-&gt;cache-&gt;getItem($key);
        return $item-&gt;getData();
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Assuming your code is well-decoupled, and you're using some sort
of Inversion of Control container, you can likely create a factory
for your ORM that will grab the above class, with the cache
injected, and inject it into the ORM instance. Yes, it's a bit more
work, but it's difficult to question the end result: shared caching
between the framework and the ORM - and no need for shared
interfaces, nor any need to sacrifice features within the framework
or the ORM.</xhtml:p>
<xhtml:h2>Sharing is good, developing solutions is better</xhtml:h2>
<xhtml:p>I think the core idea of the php-fig group is sound: <xhtml:em>let's
all start thinking about how we can make it easier to operate with
each other</xhtml:em>. That said, my thoughts on how to accomplish that
goal have changed significantly, and boil down to:</xhtml:p>
<xhtml:ul>
<xhtml:li>Use naming conventions that will reduce collisions (i.e., use
per-project vendor prefixes/namespaces)</xhtml:li>
<xhtml:li>Use semantic versioning</xhtml:li>
<xhtml:li>Keep your installation packages segregated</xhtml:li>
<xhtml:li>Have a simple, discoverable way to autoload</xhtml:li>
<xhtml:li>Provide interfaces for anything that could benefit from
alternate implementations</xhtml:li>
<xhtml:li>Don't write code that has side-effects in the global namespace
(including altering PHP settings or superglobals)</xhtml:li>
</xhtml:ul>
<xhtml:p>Following these principals, you can play nice with each other,
while still fostering innovative and differentiating solutions to
shared problems.</xhtml:p>
</xhtml:div>
    </content>
  </entry>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[PHP Master Series on Day Camp For Developers]]></title>
    <published>2012-12-18T20:24:00+0000</published>
    <updated>2012-12-18T20:24:00+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/2012-12-18-php-master-series.html"/>
    <id>http://mwop.net/blog/2012-12-18-php-master-series.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p><xhtml:a href="http://blog.calevans.com">Cal Evans</xhtml:a> has organized
another DayCamp4Developers event, this time entitled "<xhtml:a href="http://blog.calevans.com/2012/11/19/php-master-series-vol-1">PHP
Master Series, Volume 1</xhtml:a>". I'm honored to be an invited speaker
for this first edition, where I'll be presenting my talk,
"Designing Beautiful Software".</xhtml:p>
<xhtml:p>Why would you want to participate? Well, for one, because you
can interact directly with the various speakers during the
presentations. Sure, you can likely find the slide decks elsewhere,
or possibly even recordings. But if we all do our jobs right, we'll
likely raise more questions than answers; if you attend, you'll get
a chance to ask some of your questions immediately, <xhtml:em>and we may
even answer them!</xhtml:em></xhtml:p>
<xhtml:p>On top of that, this is a fantastic lineup of speakers, and,
frankly, not a lineup I've ever participated in. In a typical
conference, you'd likely see one or two of us, and be lucky if we
weren't scheduled against each other; if you attend this week,
you'll get to see us all, back-to-back.</xhtml:p>
<xhtml:p>What else will you be doing this Friday, anyways, while <xhtml:a href="http://en.wikipedia.org/wiki/2012_phenomenon">you wait for the end
of the world?</xhtml:a></xhtml:p>
<xhtml:p>So, do yourself a favor, and <xhtml:a href="http://phpmasterseriesv1.eventbrite.com/">register today</xhtml:a>!</xhtml:p>
</xhtml:div>
    </content>
  </entry>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[My ZendCon Beautiful Software Talk]]></title>
    <published>2012-11-17T13:53:00+0000</published>
    <updated>2012-11-17T13:53:00+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/2012-11-17-zendcon-beautiful-software.html"/>
    <id>http://mwop.net/blog/2012-11-17-zendcon-beautiful-software.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>Once again, I spoke at <xhtml:a href="http://www.zendcon.com/">ZendCon</xhtml:a> this year; in talking with
<xhtml:a href="http://twitter.com/chwenz">Christian Wenz</xhtml:a>, we're
pretty sure that the two of us and <xhtml:a href="http://andigutmans.blogspot.com">Andi</xhtml:a> are the only ones who
have spoken at all eight events.</xhtml:p>
<xhtml:p>Unusually for me, I did not speak on a Zend Framework topic, and
had only one regular slot (I also co-presented a Design Patterns
tutorial with my team). That slot, however, became one of my
favorite talks I've delivered: "Designing Beautiful Software". I've
given this talk a couple times before, but I completely rewrote it
for this conference in order to better convey my core message:
beautiful software is maintainable and extensible; writing software
is a craft.</xhtml:p>
<xhtml:p>I discovered today that not only was it recorded, but it's been
<xhtml:a href="http://youtu.be/mQsQ6QZ4dGg">posted on YouTube</xhtml:a>:</xhtml:p>
<xhtml:iframe width="420" height="315" src="http://www.youtube.com/embed/mQsQ6QZ4dGg" frameborder="0" allowfullscreen=""/>
<xhtml:p>I've also <xhtml:a href="/slides/2012-10-25-BeautifulSoftware/BeautifulSoftware.html">posted
the slides</xhtml:a>.</xhtml:p>
</xhtml:div>
    </content>
  </entry>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[Zend Server, ZF2, and Page Caching]]></title>
    <published>2012-11-05T21:25:00+0000</published>
    <updated>2012-11-05T21:25:00+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/2012-11-05-zend-server-caching.html"/>
    <id>http://mwop.net/blog/2012-11-05-zend-server-caching.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>Zend Server has a very cool <xhtml:a href="http://www.youtube.com/watch_v=i2XXn2SA5zM.html" target="_blank">Page Caching feature</xhtml:a>. Basically, you can provide URLs
or URL regular expressions, and tell Zend Server to provide
full-page caching of those pages. This can provide a tremendous
performance boost, without needing to change anything in your
application structure; simply enable it for a set of pages, and sit
back and relax.</xhtml:p>
<xhtml:p style="text-align: center;"><xhtml:img style="max-width: 100%; max-height: 100%;" src="/images/blog/2012-11-04-Server-CachingRule.png" alt="Zend Server Page Caching" title="Zend Server Page Caching"/></xhtml:p>
<xhtml:p>However, this feature is not entirely straight-forward when
using a framework that provides its own routing, such as ZF2. The
reason is because it assumes by default that each match maps to a
specific file on the filesystem, and prepares the caching based on
the actual <xhtml:em>file</xhtml:em> it hits. What this means for ZF2 and other
similar frameworks is that any page that matches will return the
cached version for the <xhtml:em>first</xhtml:em> match that also matches the
same <xhtml:em>file</xhtml:em> -- i.e., <xhtml:code>index.php</xhtml:code> in ZF2. That's
every page the framework handles. As an example, if I match on
<xhtml:code>/article/\d+</xhtml:code>, it matches this to the file
<xhtml:code>index.php</xhtml:code>, and then any other match that resolves to
<xhtml:code>index.php</xhtml:code> gets served that same page. Not handy.</xhtml:p>
<xhtml:p>The good part is that there's a way around this.</xhtml:p>
<xhtml:p>When creating or modifying a caching rule, simply look for the
text, "Create a separate cached page for each value of:" and click
the "Add Parameter" button. Select <xhtml:code>_SERVER</xhtml:code> from the
dropdown, and type <xhtml:code>[REQUEST_URI]</xhtml:code> for the value. Once
saved, each page that matches the pattern will be cached
separately.</xhtml:p>
<xhtml:p><xhtml:img style="max-width: 100%; max-height: 100%;" src="/images/blog/2012-11-04-Server-Caching-Request.png" alt="Zend Server Page Caching by Request" title="Zend Server Page Caching by Request"/></xhtml:p>
<xhtml:p>Note: the <xhtml:code>_SERVER</xhtml:code> key may vary based on what
environment/OS you're deployed in. Additionally, it may differ
based on how you define rewrite rules -- some frameworks and CMS
systems will append to the query string, for instance, in which
case you may want to select the "entire query string" parameter
instead of <xhtml:code>_SERVER</xhtml:code>; the point is, there's likely a way
for you to configure it.</xhtml:p>
</xhtml:div>
    </content>
  </entry>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[OpenShift, ZF2, and Composer]]></title>
    <published>2012-11-01T20:25:00+0000</published>
    <updated>2012-11-01T20:25:00+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/2012-11-01-openshift-zf2-composer.html"/>
    <id>http://mwop.net/blog/2012-11-01-openshift-zf2-composer.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>I was recently shopping around for inexpensive cloud hosting; I
want to try out a couple of ideas that may or may not have much
traffic, but which aren't suited for my VPS setup (the excellent
<xhtml:a href="http://servergrove.com/">ServerGrove</xhtml:a>); additionally,
I'm unsure how long I will maintain these projects. My budget for
this is quite small as a result; I'm already paying for hosting,
and am quite happy with it, so this is really for experimental
stuff.</xhtml:p>
<xhtml:p>I considered Amazon, Orchestra.io, and a few others, but was
concerned about the idea of a ~$50/month cost for something I'm
uncertain about.</xhtml:p>
<xhtml:p>When I asked in <xhtml:a href="irc://irc.freenode.net/zftalk.dev">#zftalk.dev</xhtml:a>, someone
suggested <xhtml:a href="http://openshift.redhat.com/">OpenShift</xhtml:a> as
an idea, and coincidentally, the very next day <xhtml:a href="http://www.zend.com/en/company/news/press/379_red-hat-expands-openshift-ecosystem-with-zend-partnership-to-offer-professional-grade-environment-for-php-developers">
Zend announced a partnership with RedHat surrounding OpenShift</xhtml:a>.
The stars were in alignment.</xhtml:p>
<xhtml:p>In the past month, in the few spare moments I've had (which
included an excellent OpenShift hackathon at ZendCon), I've created
a quick application that I've deployed and tested in OpenShift.
These are my findings.</xhtml:p>
<xhtml:h2>ZF2</xhtml:h2>
<xhtml:p>I didn't really have to do anything different to have <xhtml:a href="http://framework.zend.com/">zf2</xhtml:a> work; the standard
<xhtml:code>.htaccess</xhtml:code> provided in the skeleton application worked
flawlessly the first time (I've worked with some cloud environments
where this is not the case).</xhtml:p>
<xhtml:p>The only frustration I had was the default directory structure
OpenShift foists upon us:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
data/
libs/
misc/
php/
</xhtml:pre></xhtml:div>
<xhtml:p>This is not terrible, by any stretch. However, it's attempting
to dictate the application structure, which I'm not terribly happy
with -- particularly as my structure may vary based on the
framework I'm using (or not!), and because I may already have a
project written that I simply want to deploy.</xhtml:p>
<xhtml:p>In particular, the <xhtml:code>php</xhtml:code> directory is galling -- it's
simply the document root. Most frameworks I've used or seen call
the equivalent directory <xhtml:code>public</xhtml:code>, or <xhtml:code>web</xhtml:code>,
or <xhtml:code>html</xhtml:code> -- but never <xhtml:code>php</xhtml:code> (in large part
because the only PHP file under the document root in most
frameworks is the <xhtml:code>index.php</xhtml:code> that acts as the front
controller). It would be nice if this were configurable.</xhtml:p>
<xhtml:p>This conflicts a bit with how a ZF2 app is structured. I ended
up doing the following:</xhtml:p>
<xhtml:ul>
<xhtml:li>Removed <xhtml:code>php</xhtml:code> and symlinked my <xhtml:code>public</xhtml:code>
directory to it.</xhtml:li>
<xhtml:li>Removed <xhtml:code>libs</xhtml:code> and symlinked my <xhtml:code>vendor</xhtml:code>
directory to it.</xhtml:li>
<xhtml:li>Removed <xhtml:code>misc</xhtml:code> as I had no need to it.</xhtml:li>
</xhtml:ul>
<xhtml:p>Nothing too big, thankfully -- but problematic from the
perspective of, "I've already developed this app, but now I have to
make changes for it to work on a specific cloud vendor."</xhtml:p>
<xhtml:h2>Composer</xhtml:h2>
<xhtml:p>My next question was how to use <xhtml:a href="http://getcomposer.org/">Composer</xhtml:a> during my deployment
process, and some some googling <xhtml:a href="https://openshift.redhat.com/community/content/support-for-git-clone-on-the-server-aka-support-php-composerphar">
found some answers for me</xhtml:a>.</xhtml:p>
<xhtml:p>Basically, I needed to create a <xhtml:code>deploy</xhtml:code> task that
does two things:</xhtml:p>
<xhtml:ul>
<xhtml:li>Unset the <xhtml:code>GIT_DIR</xhtml:code> environment variable. Evidently,
the build process operates as part of a git hook, and since
Composer often uses git repositories, this can lead to
problems.</xhtml:li>
<xhtml:li>Change directory to <xhtml:code>OPENSHIFT_REPO_DIR</xhtml:code>, which is
where the application root (not document root!) lives.</xhtml:li>
</xhtml:ul>
<xhtml:p>Once I did those, I could run my normal composer installation.
The <xhtml:code>deploy</xhtml:code> task looks like this:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="bash">
#!/bin/bash
# .openshift/action_hooks/deploy
( unset GIT_DIR ; cd $OPENSHIFT_REPO_DIR ; /usr/local/zend/bin/php composer.phar install )
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>This leads into my next topic.</xhtml:p>
<xhtml:h2>Deployment</xhtml:h2>
<xhtml:p>First off, as you probably guessed from that last secton, there
<xhtml:strong>are</xhtml:strong> hooks for deployment -- it doesn't have to be
simply git. I like this, as I may have additional things I want to
do during deployment, such as retrieving and installing
site-specific configuration files, installing Composer-defined
dependencies (as already noted), etc.</xhtml:p>
<xhtml:p>Over all, this is pretty seamless, but it's not without issues.
I've been told that some of my issues are being worked on, so those
I won't bring up here. The ones that were a bit strange, and which
caught me by surprise, though, were:</xhtml:p>
<xhtml:ul>
<xhtml:li>Though the build process creates the site build from git, your
<xhtml:strong>submodules are not updated recursively</xhtml:strong>. This
tripped me up, as I was using <xhtml:a href="https://github.com/EvanDotPro/EdpMarkdown">EdpMarkdown</xhtml:a>, and
had installed it as a submodule. I ended up having to import it,
and its own submodule, directly into my project so that it would
work.</xhtml:li>
<xhtml:li>I installed the <xhtml:a href="http://www.mongodb.org/">MongoDB</xhtml:a>
cartridge. Ironically, it was not then enabled in Zend Server, and
I had to go do this. This should be turnkey.</xhtml:li>
<xhtml:li><xhtml:code>/usr/bin/php</xhtml:code> is not the same as
<xhtml:code>/usr/local/zend/bin/php</xhtml:code>. This makes no sense to me if
I've installed Zend Server as my base gear. Considering they're
different versions, this can be hugely misleading and lead to
errors. I understand there are reasons to have both -- so simply be
aware that if you use the Zend Server gear, your tasks likely
should use <xhtml:code>/usr/local/zend/bin/php</xhtml:code>.</xhtml:li>
</xhtml:ul>
<xhtml:h2>The good parts?</xhtml:h2>
<xhtml:ul>
<xhtml:li><xhtml:a href="https://openshift.redhat.com/community/faq/i-have-deployed-my-app-but-i-don%E2%80%99t-like-telling-people-to-visit-myapp-myusernamerhcloudcom-how-c">
You can alias an application to a DNS CNAME</xhtml:a> -- meaning you can
point your domain name to your OpenShift applications.
Awesome!</xhtml:li>
<xhtml:li>Simplicity of adding capabilities, such as Mongo, MySQL, Cron,
and others. In most cases, this is simply a "click on the button"
and it's installed and available.</xhtml:li>
<xhtml:li><xhtml:a href="http://www.zend.com/en/products/server">Zend
Server</xhtml:a>. For most PHP extensions, I can turn them on or off with
a few mouse clicks. If I want page-level caching, I don't have to
do anything to my application; I can simply setup some rules in the
Zend Server interface and get on with it, and enjoy tremendous
boosts to performance. I used to enjoy taming and tuning servers;
most days anymore, I just want them to work.</xhtml:li>
<xhtml:li><xhtml:a href="https://openshift.redhat.com/community/developers/remote-access">SSH</xhtml:a>
access to the server, with a number of commands to which I've been
given <xhtml:code>sudoer</xhtml:code> access. If you're going to sandbox
somebody, this is a fantastic way to do it. Oh, also: SSH tunnels
to services like Mongo and MySQL just work (via the
<xhtml:code>rhc-port-forward</xhtml:code> command).</xhtml:li>
</xhtml:ul>
<xhtml:h2>Summary</xhtml:h2>
<xhtml:p>Over all, I'm quite pleased. While it took me a bit to find the
various incantations I needed, the service is quite flexible. For
my needs, considering I'm doing experimental stuff, the price can't
be beat (the current developer preview is free). Considering most
stuff I do will fall into this or the basic tier, and that most
cartridges do not end up counting against your alotment of gears,
the pricing ($0.05/hour) is extremely competitive.</xhtml:p>
</xhtml:div>
    </content>
  </entry>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[Screencasting on Linux]]></title>
    <published>2012-09-20T22:30:00+0000</published>
    <updated>2012-09-20T22:30:00+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/2012-09-20-screencasting-on-linux.html"/>
    <id>http://mwop.net/blog/2012-09-20-screencasting-on-linux.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>I've been wanting to do screencasts on Linux for some time now,
and my big stumbling block has been determining what tools to
use.</xhtml:p>
<xhtml:p>The <xhtml:strong>tl;dr</xhtml:strong>:</xhtml:p>
<xhtml:ul>
<xhtml:li>Use <xhtml:code>recordMyDesktop</xhtml:code> to record video clips, but
afterwards, re-encode them to AVI (<xhtml:a href="#script">see the script
I used</xhtml:a>)</xhtml:li>
<xhtml:li>Record audio to WAV, or convert compressed audio to WAV format
afterwards.</xhtml:li>
<xhtml:li>Use OpenShot to stitch clips together and layer audio and video
tracks.</xhtml:li>
<xhtml:li>Remember to reset the video length if you change the playback
rate.</xhtml:li>
<xhtml:li>Export to a Web + Vimeo profile for best results.</xhtml:li>
</xhtml:ul>
<xhtml:h2 id="toc_1.1">Stumbling Blocks</xhtml:h2>
<xhtml:p><xhtml:code>recordMyDesktop</xhtml:code> is a fairly simple tool, and allows
you to record actions you're taking, and simultaneously capture
audio. However, it creates an ".ogv" (Ogg Vorbis video file) --
which is basically useless for anybody not on Linux or FreeBSD.
Additionally, I often like to record in segments; this makes it
less likely that I'll make mistakes, and, if I do, I only need to
record a small segment again, not the entire thing.
<xhtml:code>recordMyDesktop</xhtml:code> is only for creating screencasts, not
merging them.</xhtml:p>
<xhtml:p>So, <xhtml:code>recordMyDesktop</xhtml:code> went into my toolbox for the
purpose of recording the video portion of my screencasts.</xhtml:p>
<xhtml:p>Which brings me to the next point: I also prefer to record the
audio separately from the screencast portion itself; this way I
don't get typing sounds in the recording, and I'm less likely to
lose my train of thought as I'm speaking. To this end, I ended up
using quite simply the "Sound Recorder" utility
(<xhtml:code>gnome-sound-recorder</xhtml:code>). It's not great, but with a
reasonable microphone, it gets the job done. I chose to record the
audio as MP3 files.</xhtml:p>
<xhtml:p>However, this means that I now have video and audio tracks. So
my toolbox needed a utility for overlaying tracks and laying them
out on a timeline independently.</xhtml:p>
<xhtml:p>I looked at a few different free tools for Linux, including
<xhtml:code>Avidemux</xhtml:code>, <xhtml:code>Cinelerra</xhtml:code>, and
<xhtml:code>PiTiVi</xhtml:code>. <xhtml:code>Avidemux</xhtml:code> was not featurful
enough, <xhtml:code>Cinelerra</xhtml:code> was too difficult to learn (it's
more of an advanced user's tool), and <xhtml:code>PiTiVi</xhtml:code> kept
crashing on me. So, I used the lazyweb, and tweeted a question
asking what others were using -- and the unanimous response was
<xhtml:code>OpenShot</xhtml:code> (<xhtml:a href="http://www.openshotvideo.com/">http://www.openshotvideo.com/</xhtml:a>).</xhtml:p>
<xhtml:p><xhtml:code>OpenShot</xhtml:code> hit the sweet spot for me -- it was easy
to pick up, and didn't crash. However, I discovered problems when I
exported my project to a video file. My video, regardless of
whether or not I changed the playback rate, always played at about
2X normal speed. The audio always truncated 1 to 2 seconds before
completion.</xhtml:p>
<xhtml:p>In doing some research, I discovered:</xhtml:p>
<xhtml:ul>
<xhtml:li>There are known issues with Ogg Vorbis video files. Evidently,
the compression creates issues when re-encoding the video to
another format.</xhtml:li>
<xhtml:li>Similarly, compressed audio can lead to issues such as
truncation.</xhtml:li>
</xhtml:ul>
<xhtml:p>Since <xhtml:code>recordMyDesktop</xhtml:code> doesn't allow you to select
an alternate video codec, I had to use <xhtml:code>mencoder</xhtml:code> to
transcode it to another format. I chose AVI (Audio Video
Interleave, a video container format developed by Microsoft), as I
knew it had widespread support, using an mpeg4 codec (also widely
supported). I used the following script, found at <xhtml:a href="http://askubuntu.com/questions/17309/video-converter-ogv-to-avi-or-another-more-common-format">
http://askubuntu.com/questions/17309/video-converter-ogv-to-avi-or-another-more-common-format</xhtml:a>,
in order to encode my files:</xhtml:p>
<xhtml:div id="script" class="example">
<xhtml:pre>
<xhtml:code language="bash">
for f in *.ogv;do
newFile=${f%.*}
mencoder "$f" -o "$newFile.avi" -oac mp3lame -lameopts fast:preset=standard -ovc lavc -lavcopts vcodec=mpeg4:vbitrate=4000
done
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>That solved the video issue, but I still had to solve the audio
issues. I quickly re-recorded one audio segment in Sound Recorder,
and told it to use the "Voice,Lossless (.wav type)". When I used
this version of the audio, I had no issues, other than the audio
length being mis-reported within <xhtml:code>OpenShot</xhtml:code>. Instead of
re-recording all segments, I installed the "Sound Converter"
utility (`sudo aptitude isntall soundconverter`), and used that to
convert all my MP3 files to WAV. Interestingly,
<xhtml:code>OpenShot</xhtml:code> reported the audio lengths correctly this
time; go figure.</xhtml:p>
<xhtml:p>Once that was done, I was able to start stitching everything
together. A few notes, in the hopes others learn from my
mistakes:</xhtml:p>
<xhtml:ul>
<xhtml:li>Several times, I wanted my video to playback slower. This is
very easy to do: right click on the clip, select "Properties", and
select the "Speed" tab, and adjust as necessary. However, that's
not all you need to do; you need to also re-adjust the
<xhtml:em>length</xhtml:em> of the clip. Simply take the existing length, and
divide it by the rate of play. As an example, if the length is 44
seconds, and you specify a 1/2 rate (0.5), you'd do 44 / 0.5 = 88,
and set the length of the clip to 88s.</xhtml:li>
<xhtml:li>If you find that <xhtml:code>OpenShot</xhtml:code> is reporting your audio
clip lengths incorrectly, use another tool to find the accurate
length, and then set the length to that. I typically rounded up to
the next second, as most tools were giving the floor value from
rounding.</xhtml:li>
<xhtml:li>I chose to export using the Web + Vimeo HD profile. This worked
perfectly for me. It created an mpeg4 file that I could preview in
a browser, and then upload without issues. Your mileage may
vary.</xhtml:li>
</xhtml:ul>
<xhtml:p>Hopefully, this will serve as a reasonable guide for others
foraying into screencasts on Linux!</xhtml:p>
</xhtml:div>
    </content>
  </entry>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[ZF2 Modules Quickstart (Screencast)]]></title>
    <published>2012-09-19T18:10:00+0000</published>
    <updated>2012-09-19T18:10:00+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/2012-09-19-zf2-module-screencast.html"/>
    <id>http://mwop.net/blog/2012-09-19-zf2-module-screencast.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>One of the exciting features of the newly released Zend
Framework 2 is the new module system.</xhtml:p>
<xhtml:p>While ZF1 had modules, they were difficult to manage. All
resources for all modules were initialized on each request, and
bootstrapping modules was an onerous task. Due to the difficulties,
modules were never truly "plug-and-play", and thus no ecosystem
ever evolved for sharing modules.</xhtml:p>
<xhtml:p>In Zend Framework 2, we've architected the MVC from the ground
up to make modular applications as easy as possible. Within ZF2,
the MVC simply cares about events and services — and controllers
are simply one kind of service. As such, modules are primarily
about telling the MVC about services and wiring event
listeners.</xhtml:p>
<xhtml:p>To give you an example, in this tutorial, I'll show you how to
install the Zend Framework 2 skeleton application, and we'll then
install a module and see how easy it is to add it to the
application and then configure it.</xhtml:p>
<xhtml:p>To keep things simple, I'm using a unix-like environment. As
such, if you are on Windows, you may not have the same command-line
tools available. If you are in such a situation, perhaps try this
inside a Linux virtual machine.</xhtml:p>
<xhtml:iframe src="http://player.vimeo.com/video/49775540" width="500" height="281" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen=""/>
<xhtml:p><xhtml:a href="http://vimeo.com/49775540">Zend Framework 2 Module
Quickstart</xhtml:a></xhtml:p>
<xhtml:p>Let's start by creating a new project. We'll execute a few
commands to download a skeleton application archive and extract
it.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="bash">
% mkdir newproject
% cd newproject
% wget https://github.com/zendframework/ZendSkeletonApplication/tarball/master \
    -O ZendSkeletonApplication.tgz
% tar xzf ZendSkeletonApplication.tgz --strip-components=1
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>The Zend Framework skeleton application can be downloaded
directly off of <xhtml:a href="https://github.com">GitHub</xhtml:a>. I'm
showing using the download from master, but you can also download a
tarball or zipball for individual tags as well. Because the
download URL does not include an extension, I use the
<xhtml:code>-O</xhtml:code> switch to tell <xhtml:code>wget</xhtml:code> what filename to
save to.</xhtml:p>
<xhtml:p><xhtml:code>tar</xhtml:code> has a nice option,
`<xhtml:code>--strip-components</xhtml:code>`, which allows you to tell it to
descend a certain number of levels deep into the archive when
deflating. Since I know the tarball has a top-level directory named
after the repository and a sha1, I'm simply telling
<xhtml:code>tar</xhtml:code> to skip that and give me the contents of its child
directory.</xhtml:p>
<xhtml:p>At this point you have the skeleton application, but it has no
dependencies — not even Zend Framework itself! Let's rectify that
situation. We'll use the dependency management tool <xhtml:a href="https://getcomposer.org/">Composer</xhtml:a> to do this. We include the
Composer phar file within the skeleton application to make this
fairly easy. Simply execute the following:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="bash">
% php composer.phar install
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>You may get a notice indicating that the composer version is
older, and to run "self-update"; you can ignore that for now.</xhtml:p>
<xhtml:p>If all goes well, you should now have Zend Framework installed.
Let's test it out. I'm going to use the built-in web server in PHP
5.4 to demonstrate.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="bash">
% cd public
% php -S localhost:8080
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>If I browse to <xhtml:code>http://localhost:8080</xhtml:code> I should now
see the landing page for the skeleton application.</xhtml:p>
<xhtml:img src="/images/screencasts/2012-09-19-zf2-module-screencast-01-zsa.png" style="width: 100%; height: 100%;"/>
<xhtml:p>Let's add a module to the application. Many sites require a
contact form. I've written one as a module some time ago, and
called it <xhtml:a href="https://github.com/weierophinney/PhlyContact">PhlyContact</xhtml:a>. To
install it, I'll edit my project's <xhtml:code>composer.json</xhtml:code> and
tell it about that dependency:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="json">
{
    "require": {
        "php": "&gt;=5.3.3",
        "zendframework/zendframework": "dev-master",
        "phly/phly-contact": "dev-master"
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>I know the name of the component from <xhtml:a href="http://packagist.org/">http://packagist.org/</xhtml:a>, and I'm telling
Composer that I want to use whatever the latest version is on its
master branch on GitHub. I happen to also know that PhlyContact
requires a dev-master version of Zend Framework, so I'll alter that
dependency for now.</xhtml:p>
<xhtml:p>Now, we need to tell composer to update our dependencies.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="bash">
% php composer.phar update
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>After executing the command, we should now see that it has
installed; this may take a little while.</xhtml:p>
<xhtml:p>You need to inform the application about the module. This is so
that we don't have to perform expensive file-system scanning
operations, but also to make it explicit in your code what modules
you're actually using. Enabling a module is usually as easy as
adding an entry to <xhtml:code>config\application.config.php</xhtml:code>:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
'modules' =&gt; array(
    'Application',
    'PhlyContact',
),
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>This particular module provides some reasonable defaults. In
particular, it uses a CAPTCHA adapter that doesn't require
additional configuration, and assumes that you will want to use the
default <xhtml:code>Sendmail</xhtml:code> mail transport. As such, we can
simply browse to it now. I happen to know that the module defines a
<xhtml:code>/contact</xhtml:code> end point. Let's fire up our PHP web server
again, and browse to that URL.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="bash">
% cd public
% php -S localhost:8080
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:img src="/images/screencasts/2012-09-19-zf2-module-screencast-02-contact.png" style="width: 100%; height: 100%;"/>
<xhtml:p>It just works!</xhtml:p>
<xhtml:p>One philosophy we have for distributable modules in Zend
Framework 2 is that you should not need to touch the code in
modules you install in your application. Instead, you should be
able to configure and override behavior within the application
configuration or in your application's site-specific modules. Let's
alter the contact module to:</xhtml:p>
<xhtml:ul>
<xhtml:li>first, change the URL it responds to, and</xhtml:li>
<xhtml:li>second, use the "file" mail transport.</xhtml:li>
</xhtml:ul>
<xhtml:p>Let's look at the default configuration. I'll browse to
<xhtml:code>vendor/phly/phly-contact/config/</xhtml:code> and look at the
<xhtml:code>module.config.php</xhtml:code> file.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
return array(
    'phly_contact' =&gt; array(
        'captcha' =&gt; array(
            'class' =&gt; 'dumb',
        ),
        'form' =&gt; array(
            'name' =&gt; 'contact',
        ),
        'mail_transport' =&gt; array(
            'class' =&gt; 'Zend\Mail\Transport\Sendmail',
            'options' =&gt; array(
            )
        ),
        'message' =&gt; array(
            /*
            'to' =&gt; array(
                'EMAIL HERE' =&gt; 'NAME HERE',
            ),
            'sender' =&gt; array(
                'address' =&gt; 'EMAIL HERE',
                'name'    =&gt; 'NAME HERE',
            ),
            'from' =&gt; array(
                'EMAIL HERE' =&gt; 'NAME HERE',
            ),
             */
        ),
    ),

    /* ... */

    'router' =&gt; array(
        'routes' =&gt; array(
            'contact' =&gt; array(
                'type' =&gt; 'Literal',
                'options' =&gt; array(
                    'route' =&gt; '/contact',
                    'defaults' =&gt; array(
                        '__NAMESPACE__' =&gt; 'PhlyContact\Controller',
                        'controller'    =&gt; 'Contact',
                        'action'        =&gt; 'index',
                    ),
                ),
                'may_terminate' =&gt; true,
                'child_routes' =&gt; array(
                    'process' =&gt; array(
                        'type' =&gt; 'Literal',
                        'options' =&gt; array(
                            'route' =&gt; '/process',
                            'defaults' =&gt; array(
                                'action' =&gt; 'process',
                            ),
                        ),
                    ),
                    'thank-you' =&gt; array(
                        'type' =&gt; 'Literal',
                        'options' =&gt; array(
                            'route' =&gt; '/thank-you',
                            'defaults' =&gt; array(
                                'action' =&gt; 'thank-you',
                            ),
                        ),
                    ),
                ),
            ),
        ),
    ),
    /* ... */
);
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Okay, that's interesting. I can define the captcha and options
to use, the name of the contact form, the mail transport I want to
use, and even who the email is sent from and who it goes to. In
addition, it defines some routes.</xhtml:p>
<xhtml:p>I'll create a new file,
<xhtml:code>config/autoload/phly-contact.local.php</xhtml:code>. This is a
local configuration file that will not be checked into my version
control system. Now, let's add some configuration. First, I'll
configure my mail transport.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
return array(
    'phly_contact' =&gt; array(
        'mail_transport' =&gt; array(
            'class'   =&gt; 'Zend\Mail\Transport\File',
            'options' =&gt; array(
                'path' =&gt; 'data/mail/',
            ),
        ),
    ),
);
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>I'm telling the module to use the <xhtml:code>File</xhtml:code> mail
transport, and telling the transport where I want messages written.
By default, Zend Framework calls <xhtml:code>chdir()</xhtml:code> to change
directory to the project root, so I can reference a directory
relative to that. I'm simply going to write to a
<xhtml:code>data/mail/</xhtml:code> directory. Let's create that, and make it
world-writable for now to ensure the web server can write to it.
(In production, you'd only want it writable by the web server
user.)</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="bash">
% mkdir -p data/mail
% chmod a+rwX data/mail
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Now, let's change the base URL the contact form responds to; I
want it to respond to <xhtml:code>/contact-us</xhtml:code>. Another principle
of re-usable modules in ZF2 is that we recommend creating tree
routes for each module, with the root of the tree being a literal
route. This makes it easy to alter the base for routing, without
needing to redefine all the routes in the module.</xhtml:p>
<xhtml:p>I'll add the following to my local configuration, then. I'll
simply override the parent route for my module, named "contact",
and point it at a different URL.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
'router' =&gt; array(
    'routes' =&gt; array(
        'contact' =&gt; array(
            'options' =&gt; array(
                'route' =&gt; '/contact-us',
            ),
        ),
    ),
),
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Let's see if all this worked! Once again, I'll fire up PHP's
built-in web server.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="bash">
% cd public
% php -S localhost:8080
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Now, let's browse to
<xhtml:code>http://localhost:8080/contact-us</xhtml:code> -- looks good! Just
as an experiment, let's try the previously configured URL,
<xhtml:code>http://localhost:8080/contact</xhtml:code>. We get a 404 now!</xhtml:p>
<xhtml:img src="/images/screencasts/2012-09-19-zf2-module-screencast-03-config.png" style="width: 100%; height: 100%;"/> <xhtml:img src="/images/screencasts/2012-09-19-zf2-module-screencast-04-404.png" style="width: 100%; height: 100%;"/>
<xhtml:p>Now, let's submit the form. I'll fill in some information; it's
asking for my email address, a subject line, and a message, as well
as for me to solve a simple CAPTCHA. Once I've done all that, I can
send it.</xhtml:p>
<xhtml:p>If all is well, we should now have a mail file in our data
directory. Let's check.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="bash">
% ls -l data/mail/
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>And now let's look at it.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="bash">
% cat data/mail/ZendMail_1347989389_1009740165.tmp
Date: Tue, 18 Sep 2012 12:29:49 -0500
From: me@mwop.net
Reply-To: me@mwop.net
Subject: [Contact Form] Suspense!

Suspenseful, isn't it?
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Looks good!</xhtml:p>
<xhtml:p>Zend Framework 2 provides a wonderful modular architecture that
will enable an ecosystem of 3rd party modules that should save you
time and energy when developing your applications. I've
demonstrated a simple one, a contact form, but many, many more
already exist, and with a stable release now available, you should
see that number grow. This is truly a wonderful step forward for
developers, and I hope you find it as exciting as I do.</xhtml:p>
</xhtml:div>
    </content>
  </entry>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[On Microframeworks]]></title>
    <published>2012-08-17T16:00:00+0000</published>
    <updated>2012-08-17T16:00:00+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/2012-08-17-on-microframeworks.html"/>
    <id>http://mwop.net/blog/2012-08-17-on-microframeworks.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>A number of months ago, <xhtml:a href="http://funkatron.com/">Ed
Finkler</xhtml:a> started a discussion in the PHP community about
“<xhtml:a href="http://microphp.org/">MicroPHP</xhtml:a>”; to summarize, the
movement is about:</xhtml:p>
<xhtml:ul>
<xhtml:li>Building small, single-purpose libraries.</xhtml:li>
<xhtml:li>Using small things that work together to solve larger
problems.</xhtml:li>
</xhtml:ul>
<xhtml:p>I think there are some really good ideas that have come out of
this, and also a number of questionable practices<xhtml:sup><xhtml:a name="t1" href="#f1">1</xhtml:a></xhtml:sup>.</xhtml:p>
<xhtml:p>One piece in particular I've focussed on is the concept of
so-called “microframeworks”.</xhtml:p>
<xhtml:h2>What is a microframework?</xhtml:h2>
<xhtml:p>PHP has had microframeworks for quite some time<xhtml:sup><xhtml:a name="t2" href="#f2">2</xhtml:a></xhtml:sup>, though I only really first saw the term
being used around 3 years ago. The “grand-daddy” of modern-day
microframeworks can actually be traced to Ruby, however, and
specifically <xhtml:a href="http://www.sinatrarb.com">Sinatra</xhtml:a>.</xhtml:p>
<xhtml:p>Sinatra is not so much a framework as it is a domain-specific
language (DSL). The language and structure it created, however,
have been re-created in the vast majority of microframeworks you
see currently in the PHP arena. Specifically, it describes how to
map HTTP request methods and paths to the code that will handle
them. It borrowed route matching ideas from <xhtml:a href="http://rubyonrails.org/">Ruby on Rails</xhtml:a>, and relied on the fact
that Ruby uses the last value of a block as the return value.</xhtml:p>
<xhtml:p>As some simple examples:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="ruby">
get '/hello/:name' do |n|
    "Hello #{n}!"
end

post '/address'
    # create address
end

put '/address/:id' |i|
    # update address
end

get '/feed.?:format?', :provides =&gt; ['rss', 'atom', 'xml'] do
    builder :feed
end
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>The language is expressive, and allows the developer to focus on
two things:</xhtml:p>
<xhtml:ul>
<xhtml:li>What are the specific entry points (URIs) for the
application?</xhtml:li>
<xhtml:li>What needs to be done for each specific entry point?</xhtml:li>
</xhtml:ul>
<xhtml:p>I'd argue that the above two points are the defining
characteristics of modern microframeworks. Typically, the entry
points are given the term “routing ”, and the second corresponds to
“controllers”.</xhtml:p>
<xhtml:h2>PHP implementations</xhtml:h2>
<xhtml:p>I'd argue one of the earliest microframework implementations,
though it wasn't termed as such, was <xhtml:a href="http://dev.horde.org/routes/">Horde Routes</xhtml:a><xhtml:sup><xhtml:a name="t3" href="#f3">3</xhtml:a></xhtml:sup> (which was itself inspired by <xhtml:a href="http://routes.readthedocs.org/en/latest/index.html">Python
Routes</xhtml:a>, in turn inspired by the Rails routing system, like
Sinatra). It follows the two principles I outlined above: it allows
defining routes (entry points), and mapping them to controllers.
Controllers for Routes are simply classes, and a route must provide
both a controller and an action in the match, with the latter
corresponding to a method on the controller class.</xhtml:p>
<xhtml:p>Since around 2009, I've seen an increasing number of new PHP
microframeworks<xhtml:sup><xhtml:a name="t4" href="#f4">4</xhtml:a></xhtml:sup> that follow
in the steps of Sinatra and Horde. In the various implementations
I've looked at, instead of using a DSL, the authors have all opted
for either a procedural or OOP interface. Starting with PHP 5.3,
most authors have also primarily targetted any PHP callable as a
controller, favoring callbacks specifically. The fundamental ideas
remain the same as Sinatra, however:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
/* Procedural */
get('/hello/:name', function ($n) {
    return "Hello {$n}!";
});

post('/address', function () {
    // create address
});

put('/address/:id' function ($i) {
    // update address
});

get('/feed.?:format?', function($feed, $format) {
    return builder($feed, $format);
});

/* OOP */
$app-&gt;get('/hello/:name', function ($n) {
    return "Hello {$n}!";
});

$app-&gt;post('/address', function () {
    // create address
});
end

$app-&gt;put('/address/:id', function ($i) {
    // update address
});

$app-&gt;get('/feed.?:format?', function ($feed, $format) use ($app) {
    return $app-&gt;builder($feed, $format);
})-&gt;constraints(['format' =&gt; '/^(rss|atom|xml)$/']);
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>One key difference I've witnessed in the implementations is
surrounding how route matches are passed to the callback. In the
examples above, they are passed as individual arguments to the
handler. Some, however, opt for an approach more like Sinatra,
which passes a single "params" argument into the scope of the
handler. This approach tends to be more expedient both from an
implementation standpoint as well as a performance standpoint, as
it does not require reflection to determine name and position of
arguments, and makes handling wildcard arguments simpler. I've seen
this latter approach handled several ways:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
// Pass in route match parameters as an argument.
$app-&gt;get('/feed.:format', function ($params) {
    $format = $params['format'];
});

// Pass in the $app instance, and retrieve route 
// match parameters from it.
$app-&gt;get('/feed.:format', function ($app) {
    $format = $app-&gt;params('format');
});

// Curry in the $app instance when desired, and 
// retrieve route match parameters from it.
$app-&gt;get('/feed.:format', function () use ($app) {
    $format = $app-&gt;params('format');
});
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Another difference I've seen is in how route constraints,
defaults, and names are handled. The most elegant solutions usually
allow chaining method calls in order to alter this data:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
$app-&gt;get('/feed.:format', function ($app) {
  })-&gt;constraints(['format' =&gt; '/^(atom|xml|json)$/'])
    -&gt;name('feed');
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>One common feature I've seen is the ability to generate URLs
based on the defined routes. Most commonly, this is a function or
method <xhtml:code>urlTo()</xhtml:code>, which takes a route name, and an
associative array of replacements.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
echo $app-&gt;urlTo('feed', ['format' =&gt; 'atom']);
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>That's it in a nutshell: the ability to match HTTP request
methods and path information, and map it to controllers/handlers,
and to generate URLs based on those present in the application.</xhtml:p>
<xhtml:h2>What are they good for?</xhtml:h2>
<xhtml:p>In my research and experience, microframeworks have three
typical use cases:</xhtml:p>
<xhtml:ol>
<xhtml:li><xhtml:b>Prototyping.</xhtml:b> Because of their simplicity,
microframeworks are fantastic for prototyping a basic website. Very
often, in the early stages of a site, you have a limited number of
pages, and most often simply need to render a template with limited
variable substitutions. Microframeworks are a perfect fit for
this.</xhtml:li>
<xhtml:li><xhtml:b>APIs</xhtml:b>. API needs are usually quite well-defined, and
often involve a small, finite number of URLs. The logic required is
usually already encapsulated in business objects, so the
application layer is simply for filtering and returning a
representation. Microframeworks again offer a nice fit.</xhtml:li>
<xhtml:li><xhtml:b>Small, mostly static sites</xhtml:b>. Similar to the first point,
if you know the site will be relatively small and mostly static,
then the minimal overhead of a microframework is often a good
fit.</xhtml:li>
</xhtml:ol>
<xhtml:h2>Where do microframeworks fail?</xhtml:h2>
<xhtml:p>Because of the rather declarative nature of microframeworks, and
the typically 1:1 mapping of a route to a controller,
microframeworks do not tend to promote code re-use. Additionally,
this extends to how microframework applications are organized:
usually, there are no clear guidelines on how to organize routes
and controllers, much less separate them into multiple files. This
can lead to maintenance issues as the application grows, as well as
logistical issues whenever you need to add new routes and
controllers (do they go at the top, or bottom? are there other
routes that could potentially match as well? etc.).</xhtml:p>
<xhtml:p>Additionally, though many frameworks offer ways to alter the
workflow of the application either via hooks, events, or
“middleware”<xhtml:sup><xhtml:a name="t5" href="#f5">5</xhtml:a></xhtml:sup>, most of these
are limited in scope, often non-reusable, and often non-stackable.
As such, comprehensive manipulation of the application workflow is
out of reach.</xhtml:p>
<xhtml:p>One other area that is overlooked, however, is one I find
curious, particularly in light of the MicroPHP movement: so much of
the underlying plumbing is basically the same, yet every
microframework re-implements it. Specifically:</xhtml:p>
<xhtml:ul>
<xhtml:li>Routing is basically the same across most implementations,
following the same basic specifications outlined in Rails. There
are very few differences in the public APIs.</xhtml:li>
<xhtml:li>Request and Response object abstraction is largely the same as
well, providing access to query/post/cookie/session/etc. parameters
through roughly equivalent APIs.</xhtml:li>
<xhtml:li>Many implement their own view layers.<xhtml:sup><xhtml:a name="t6" href="f6">6</xhtml:a></xhtml:sup></xhtml:li>
</xhtml:ul>
<xhtml:p>Most of this code should be considered commodity code at this
point. There are several outstanding view layers and templating
engines available (Smarty, Twig, Savant, Zend\View). Standalone
routing libraries exist such as Horde Routes, and even those
bundled with frameworks are often available separately via Composer
or Pyrus; the same is true with Request and Response object
abstraction. It seems to me that a few microframework authors
should be working on abstracting these concerns, and then focussing
their efforts on differentiators in their own microframeworks.</xhtml:p>
<xhtml:h2>An experiment</xhtml:h2>
<xhtml:p>Building on my last point, I looked at the APIs of <xhtml:a href="http://limonade-php.github.com/">Limonade</xhtml:a> and <xhtml:a href="http://www.slimframework.com/">Slim Framework</xhtml:a>, and built up a
specification for a microframework. I then matched as many pieces
of it as possible to existing components in <xhtml:a href="http://packages.zendframework.com/">ZF2</xhtml:a>, and started
building.</xhtml:p>
<xhtml:p>In a matter of a few hours, I had written up a complete test
suite<xhtml:sup><xhtml:a name="t7" href="#f7">7</xhtml:a></xhtml:sup> and all code for a
microframework, featuring the following (this is basically the
testdox output from the unit test suite):</xhtml:p>
<xhtml:ul>
<xhtml:li>Lazy loads request</xhtml:li>
<xhtml:li>Lazy loads response</xhtml:li>
<xhtml:li>Request is injectible</xhtml:li>
<xhtml:li>Response is injectible</xhtml:li>
<xhtml:li>Halt should raise halt exception</xhtml:li>
<xhtml:li>Response should contain status provided to halt</xhtml:li>
<xhtml:li>Response should contain message provided to halt</xhtml:li>
<xhtml:li>Stop should raise halt exception</xhtml:li>
<xhtml:li>Response should remain unaltered after stop</xhtml:li>
<xhtml:li>Redirect should raise halt exception</xhtml:li>
<xhtml:li>Redirect should set 302 response status by default</xhtml:li>
<xhtml:li>Redirect should set response status based on provided status
code</xhtml:li>
<xhtml:li>Redirect should set location header</xhtml:li>
<xhtml:li>Map creates a segment route when provided with a string
route</xhtml:li>
<xhtml:li>Map can receive a route object</xhtml:li>
<xhtml:li>Passing invalid route raises exception</xhtml:li>
<xhtml:li>Map can receive a callable</xhtml:li>
<xhtml:li>Passing invalid controller to route does not immediately raise
exception</xhtml:li>
<xhtml:li>Accessing invalid controller raises exception</xhtml:li>
<xhtml:li>Passing invalid method to route via method raises
exception</xhtml:li>
<xhtml:li>Can set methods route responds to singly</xhtml:li>
<xhtml:li>Can set methods route responds to as array</xhtml:li>
<xhtml:li>Can set methods route responds to as multiple arguments</xhtml:li>
<xhtml:li>Can specify additional method types to respond to</xhtml:li>
<xhtml:li>Can specify route name</xhtml:li>
<xhtml:li>Adding route using method type creates route that responds to
that method type</xhtml:li>
<xhtml:li>Running with no matching routes raises page not found
exception</xhtml:li>
<xhtml:li>Routing sets list of named routes</xhtml:li>
<xhtml:li>Routing sets lists of routes by method</xhtml:li>
<xhtml:li>Successful routing dispatches controller</xhtml:li>
<xhtml:li>Unsuccessful routing triggers 404 event</xhtml:li>
<xhtml:li>Calling halt triggers halt event</xhtml:li>
<xhtml:li>Invalid controller triggers 501 event</xhtml:li>
<xhtml:li>Exception raised in controller triggers 500 event</xhtml:li>
<xhtml:li>Can pass to next matching route</xhtml:li>
<xhtml:li>Url for helper assembles url based on name provided</xhtml:li>
<xhtml:li>Url for helper assembles url based on name and params
provided</xhtml:li>
<xhtml:li>Url for helper assembles url based on current route match when
no name provided</xhtml:li>
<xhtml:li>Composes logger instance by default</xhtml:li>
<xhtml:li>Can inject specific logger instance</xhtml:li>
<xhtml:li>Mustache view is used by default</xhtml:li>
<xhtml:li>Can inject alternate view instance</xhtml:li>
<xhtml:li>Render renders a template to the response</xhtml:li>
<xhtml:li>View model returns mustache view model by default</xhtml:li>
<xhtml:li>Subsequent calls to view model return separate instances</xhtml:li>
<xhtml:li>Can provide view model prototype</xhtml:li>
</xhtml:ul>
<xhtml:p>I utilized ZF2's routing library from its MVC component, the
request and response objects from its HTTP component, its Log
component, and the Session component. These had a few other
dependencies, but nothing terribly onerous.</xhtml:p>
<xhtml:p>For the view, I used my own <xhtml:a href="http://weierophinney.github.com/phly_mustache">phly_mustache</xhtml:a>,
and provided a basic "view model" implementation that receives the
application instance, thus allowing the ability to call application
helpers (such as url generation).</xhtml:p>
<xhtml:p>To make installation simple, I used <xhtml:a href="http://getcomposer.org">Composer</xhtml:a> to manage my dependencies on
specific ZF2 components and for phly_mustache. The microframework
contains only the code it needs to get its work done, leveraging
the work of others whenever possible.</xhtml:p>
<xhtml:p>This post is not meant as a way to announce a new
microframework, however.<xhtml:sup><xhtml:a name="t8" href="#f8">8</xhtml:a></xhtml:sup>
The point of the experiment was to prove something: microframeworks
are trivially easy to write, <xhtml:em>particularly if you follow the
principals of MicroPHP, and re-use existing code</xhtml:em>. Just because
code comes from a framework or a third-party library does not make
it suspect or inferior; in fact, whenever possible, you should
leverage such code so you can focus on <xhtml:em>writing awesome
applications</xhtml:em>.</xhtml:p>
<xhtml:h2>Lessons learned</xhtml:h2>
<xhtml:p>I really like microframeworks for specific problems:
prototyping, APIs, and small, simple sites. I think they are
ideally suited for these tasks. That said, I'd love to see some
solid libraries targetting the fundamental, shared aspects of these
efforts: routing, request and response abstraction, etc. With
dependency management tools such as Composer and Pyrus, having
required dependencies is not a big deal anymore, and re-use should
be encouraged.</xhtml:p>
<xhtml:p>Also, writing a microframework is an excellent coding exercise.
It helps a developer appreciate the complexities of abstraction
while limiting the number of moving parts. I highly recommend it as
an exercise -- but do it using available components, and be
prepared to throw it away and instead collaborate with others, or
adopt something which better solves both the problems you have and
the problems you anticipate.</xhtml:p>
<xhtml:p>In sum: <xhtml:em>Use the right tool for the job</xhtml:em>. If you foresee
expanding requirements in your project's future, you may want to
evaluate a full-stack framework,<xhtml:sup><xhtml:a name="t9" href="#f9">9</xhtml:a></xhtml:sup> or consider building something robust that suits
your specific project's needs. Use microframeworks where and when
they make sense.</xhtml:p>
<xhtml:h4>Afterword</xhtml:h4>
<xhtml:p>I'm well aware that Fabien Potencier has written <xhtml:a href="http://fabien.potencier.org/article/50/create-your-own-framework-on-top-of-the-symfony2-components-part-1">
a comprehensive series of posts on creating a microframework using
Symfony 2 components</xhtml:a>. I deliberately chose not to read them
until (a) ZF2 was almost ready to release, and (b) I'd had a chance
to formulate my own opinions on microframeworks. They're an
excellent read, however, and show a nice progression of development
from flat PHP to a fully functional microframework; click the link
and see for yourself.</xhtml:p>
<xhtml:h4>Footnotes</xhtml:h4>
<xhtml:ul>
<xhtml:li><xhtml:sup><xhtml:a name="f1" href="#t1">1</xhtml:a></xhtml:sup> In particular, I feel
that the movement (a) disparages components from larger libraries
simply because they originate from a larger library, and (b)
distrust any code that has additional dependencies. This latter I
find truly puzzling, as I'd think it fits the idea of “use small
things that work together to solve larger problems.” If the code
solves a particular problem and allows you to focus on a larger
problem, where it originates and the number of dependencies should
not be an issue.</xhtml:li>
<xhtml:li><xhtml:sup><xhtml:a name="f2" href="#t2">2</xhtml:a></xhtml:sup> In fact, my first
foray into MVC in PHP was writing a clone of Perl's <xhtml:a href="http://cgi-app.org/">CGI::Application</xhtml:a>, which in many ways is
also a microframework.</xhtml:li>
<xhtml:li><xhtml:sup><xhtml:a name="f3" href="#t3">3</xhtml:a></xhtml:sup> Trivia: Both authors
of Horde Routes worked at Zend when I first started at the company,
and Mike Naberezny wrote the very first lines of code for Zend
Framework.</xhtml:li>
<xhtml:li><xhtml:sup><xhtml:a name="f4" href="#t4">4</xhtml:a></xhtml:sup> I swear, you see new
ones on Github daily, and on <xhtml:a href="http://phpdeveloper.org/">PHP
Developer</xhtml:a> at least once a week.</xhtml:li>
<xhtml:li><xhtml:sup><xhtml:a name="f5" href="#t5">5</xhtml:a></xhtml:sup> <xhtml:a href="http://www.slimframework.com">Slim</xhtml:a> has this concept.
Basically, any callables placed between the route string and the
last callable when defining a route -- i.e., the “middle”
arguments, and thus middleware -- will be executed in order prior
to attempting to execute the controller.</xhtml:li>
<xhtml:li><xhtml:sup><xhtml:a name="f6" href="#t6">6</xhtml:a></xhtml:sup> <xhtml:a href="http://www.slimframework.com">Slim</xhtml:a> is an outlier here, as it
utilizes <xhtml:a href="http://twig.sensiolabs.org/">Twig</xhtml:a> by
default.</xhtml:li>
<xhtml:li><xhtml:sup><xhtml:a name="f7" href="#t7">7</xhtml:a></xhtml:sup> I'm sure that my TDD
experiment will warm the soul of <xhtml:a href="http://www.littlehart.net/atthekeyboard/" alt="Chris Hartjes">the
Grumpy Programmer</xhtml:a>.</xhtml:li>
<xhtml:li><xhtml:sup><xhtml:a name="f8" href="#t8">8</xhtml:a></xhtml:sup> That said, if you want
to look at the results, you can <xhtml:a href="http://github.com/weierophinney/phlyty">find Phlyty on
Github</xhtml:a>.</xhtml:li>
<xhtml:li><xhtml:sup><xhtml:a name="f9" href="#t9">9</xhtml:a></xhtml:sup> As you may guess, I'm
biased towards <xhtml:a href="http://framework.zend.com/">Zend
Framework</xhtml:a>. However, you should always carefully evaluate a
framework against your project's needs.</xhtml:li>
</xhtml:ul>
</xhtml:div>
    </content>
  </entry>
  <entry xmlns:xhtml="http://www.w3.org/1999/xhtml">
    <title type="html"><![CDATA[ZF2's New Controller::init()]]></title>
    <published>2012-07-30T20:40:00+0000</published>
    <updated>2012-07-31T02:00:00+0000</updated>
    <link rel="alternate" type="text/html" href="http://mwop.net/blog/2012-07-30-the-new-init.html"/>
    <id>http://mwop.net/blog/2012-07-30-the-new-init.html</id>
    <author>
      <name>Matthew Weier O'Phinney</name>
      <email>me@mwop.net</email>
      <uri>http://mwop.net</uri>
    </author>
    <content xmlns:xhtml="http://www.w3.org/1999/xhtml" type="xhtml">
      <xhtml:div xmlns:xhtml="http://www.w3.org/1999/xhtml"><xhtml:p>In Zend Framework 1, controller's had an <xhtml:code>init()</xhtml:code>
method, which was called after the controller was instantiated. The
reason for it was to encourage developers not to override the
constructor, and thus potentially break some of the functionality
(as a number of objects were injected via the constructor).
<xhtml:code>init()</xhtml:code> was useful for doing additional object
initialization.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
class MyController extends Zend_Controller_Action
{
    public function init()
    {
        // do some stuff!
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>But this feature is missing from ZF2; how can we accomplish this
sort of pattern?</xhtml:p>
<xhtml:h2>Constructor Overriding</xhtml:h2>
<xhtml:p>Why didn't we add the <xhtml:code>init()</xhtml:code> method in Zend
Framework 2? Because we don't have a constructor by default, and
also to reduce overall method calls; if a controller won't be
overriding the method, there's no reason to make the call in the
first place. So, that means, in ZF2, unlike ZF1, to do the same
thing, you can simply define a constructor in your controller:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
use Zend\Mvc\Controller\AbstractActionController;

class MyController extends AbstractActionController
{
    public function __construct()
    {
        // do some stuff!
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>Except there's one specific and often-needed use case where this
fails: if you want to wire listeners to the controller's event
manager.</xhtml:p>
<xhtml:h2>Events</xhtml:h2>
<xhtml:p>Why does this fail with the event manager? Because when we're in
the constructor, we don't yet have an <xhtml:code>EventManager</xhtml:code>
instance! The event manager instance is injected after
instantiation. As such, we need to attach to it once we know we
have an event manager. Which is... when it's set. This can be done
very simply by overriding the <xhtml:code>setEventManager()</xhtml:code>
method. In the next example, we'll define a listener for the
"dispatch" event that redirects if certain criteria is not met.</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
use Zend\EventManager\EventManagerInterface;
use Zend\Mvc\Controller\AbstractActionController;

class MyController extends AbstractActionController
{
    public function setEventManager(EventManagerInterface $events)
    {
        parent::setEventManager($events);

        $controller = $this;
        $events-&gt;attach('dispatch', function ($e) use ($controller) {
            $request = $e-&gt;getRequest();
            $method  = $request-&gt;getMethod();
            if (!in_array($method, array('PUT', 'DELETE', 'PATCH'))) {
                // nothing to do
                return;
            }

            if ($controller-&gt;params()-&gt;fromRoute('id', false)) {
                // nothing to do
                return;
            }

            // Missing identifier! Redirect.
            return $controller-&gt;redirect()-&gt;toRoute(/* ... */);
        }, 100); // execute before executing action logic
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>The beauty of this is that we only override when we need to, and
we override in the specific context we're trying to influence.
Additionally, we're only registering the event listener if this
particular controller is instantiated -- which helps reduce our
overall number of listeners, and thus shapes our call graph based
on the controller invoked.</xhtml:p>
<xhtml:h2>Other dependencies</xhtml:h2>
<xhtml:p>As you'll likely note, the event manager is not the only case
where you may need to follow a similar pattern. Any time your
initialization logic may be based on a dependency, you'll want to
override the setter in which that dependency is injected.</xhtml:p>
<xhtml:p><xhtml:em>Got any ZF2 tips of your own to share? Blog them!</xhtml:em></xhtml:p>
<xhtml:h2>Update: ServiceManager</xhtml:h2>
<xhtml:p>A few folks in the comments were remarking that the felt that
omitting the <xhtml:code>init()</xhtml:code> method makes it harder for
developers to identify when and where to do initialization logic,
particularly when you may be working with multiple
dependencies.</xhtml:p>
<xhtml:p>Which made me realize there's another place I missed, one that's
potentially even better suited to initialization: the
<xhtml:code>ServiceManager</xhtml:code>.</xhtml:p>
<xhtml:p>Basically, if you find yourself having complex initialization
needs, or many dependencies, you should be building a factory for
your controller, and wiring it to the <xhtml:code>ServiceManager</xhtml:code>.
This can happen in one of several places, but my preference is in
my module's <xhtml:code>Module</xhtml:code> class, in the
<xhtml:code>getControllerConfig()</xhtml:code> method. This method returns
configuration for the controller manager that instantiates,
validate, and injects controllers; it's basically a type of
<xhtml:code>ServiceManager</xhtml:code>, and, in fact, has access to the main
application's instance. I'll take the previous example, and wire it
in the context of a factory:</xhtml:p>
<xhtml:div class="example">
<xhtml:pre>
<xhtml:code language="php">
namespace My

use Zend\EventManager\EventManagerInterface;

class Module
{
    /*
     * Assume some other methods, such as getConfig(), etc.
     * Also assume that a route will return a controller named
     * "My\Controller\My" which we assume will reference a controller
     * within our current namespace.
     */

    public function getControllerConfig()
    {
        return array('factories' =&gt; array(
            'My\Controller\My' =&gt; function ($controllers) {
                $services   = $controllers-&gt;getServiceLocator();
                $controller = new Controller\MyController();
                $events     = $services-&gt;get('EventManager')

                $events-&gt;attach('dispatch', function ($e) use ($controller) {
                    $request = $e-&gt;getRequest();
                    $method  = $request-&gt;getMethod();
                    if (!in_array($method, array('PUT', 'DELETE', 'PATCH'))) {
                        // nothing to do
                        return;
                    }

                    if ($controller-&gt;params()-&gt;fromRoute('id', false)) {
                        // nothing to do
                        return;
                    }

                    // Missing identifier! Redirect.
                    return $controller-&gt;redirect()-&gt;toRoute(/* ... */);
                }, 100); // execute before executing action logic

                $controller-&gt;setEventManager($events);
                return $controller;
            };
        ));
    }
}
</xhtml:code>
</xhtml:pre></xhtml:div>
<xhtml:p>The above will create the controller, grab an event manager
instance, attach the listener, and then inject the event manager
into the controller. If you wanted to do more complex work, you
definitely could -- and this would be the place to do it.</xhtml:p>
</xhtml:div>
    </content>
  </entry>
</feed>
